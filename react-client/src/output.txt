// Author: Batya

// Source: App.css
#root {
  max-width: 1280px;
  margin: 0 auto;
  padding: 2rem;
  text-align: center;
}

.logo {
  height: 6em;
  padding: 1.5em;
  will-change: filter;
  transition: filter 300ms;
}
.logo:hover {
  filter: drop-shadow(0 0 2em #646cffaa);
}
.logo.react:hover {
  filter: drop-shadow(0 0 2em #61dafbaa);
}

@keyframes logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

@media (prefers-reduced-motion: no-preference) {
  a:nth-of-type(2) .logo {
    animation: logo-spin infinite 20s linear;
  }
}

.card {
  padding: 2em;
}

.read-the-docs {
  color: #888;
}


// Source: App.tsx
import React from 'react';
import { BrowserRouter as Router, Routes, Route, Navigate } from 'react-router-dom';
import { ChakraProvider, ColorModeScript } from '@chakra-ui/react';
import { AuthProvider, useAuth } from './contexts/AuthContext';
import TripProvider from './contexts/TripContext';
import theme from './theme';

// Layout components
import Header from './components/layout/Header';
import Footer from './components/layout/Footer';

// Pages
import HomePage from './pages/HomePage';
import LoginPage from './pages/auth/LoginPage';
import RegisterPage from './pages/auth/RegisterPage';
import NotFoundPage from './pages/NotFoundPage';
import TripDetailPage from './pages/trips/TripDetailPage';
import TripsPage from './pages/trips/TripsPage';
import TripFormPage from './pages/trips/TripFormPage';
import SharedTripPage from './pages/trips/SharedTripPage';

// Protected Route component
const ProtectedRoute = ({ children }: { children: React.ReactNode }) => {
  const { currentUser, loading } = useAuth();

  if (loading) {
    return null; // Or loading spinner
  }

  return currentUser ? <>{children}</> : <Navigate to="/login" />;
};

function App() {
  return (
    <>
      {/* הוספת סקריפט מצב צבע */}
      <ColorModeScript initialColorMode={theme.config.initialColorMode} />
      <ChakraProvider theme={theme}>
        <Router>
          <AuthProvider>
            <TripProvider>
              <Header />
              <Routes>
                {/* Public routes */}
                <Route path="/" element={<HomePage />} /> {/* שינוי כאן - עמוד הבית עכשיו ציבורי */}
                <Route path="/login" element={<LoginPage />} />
                <Route path="/register" element={<RegisterPage />} />
                <Route path="/trips/shared/:shareId" element={<SharedTripPage />} />

                {/* Protected routes */}
                <Route path="/trips" element={
                  <ProtectedRoute>
                    <TripsPage />
                  </ProtectedRoute>
                } />

                <Route path="/trips/new" element={
                  <ProtectedRoute>
                    <TripFormPage />
                  </ProtectedRoute>
                } />

                <Route path="/trips/:id" element={
                  <ProtectedRoute>
                    <TripDetailPage />
                  </ProtectedRoute>
                } />

                <Route path="/trips/:id/edit" element={
                  <ProtectedRoute>
                    <TripFormPage isEditing />
                  </ProtectedRoute>
                } />

                {/* Catch-all route for 404 */}
                <Route path="*" element={<NotFoundPage />} />
              </Routes>
              <Footer />
            </TripProvider>
          </AuthProvider>
        </Router>
      </ChakraProvider>
    </>
  );
}

export default App;

// Source: index.css
* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

html, body, #root {
  width: 100%;
  height: 100%;
  margin: 0;
  padding: 0;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
}

#root {
  display: flex;
  flex-direction: column;
}

.leaflet-container {
  width: 100%;
  height: 100%;
}

// Source: main.tsx
import { StrictMode } from 'react'
import { createRoot } from 'react-dom/client'
import './index.css'
import App from './App.tsx'
import 'leaflet/dist/leaflet.css';

createRoot(document.getElementById('root')!).render(
  <StrictMode>
    <App />
  </StrictMode>,
)


// Source: vite-env.d.ts
/// <reference types="vite/client" />


// Source: contexts\AuthContext.tsx
import React, { createContext, useContext, useState, useEffect, ReactNode } from 'react';
import { useNavigate } from 'react-router-dom';
import { useToast } from '@chakra-ui/react';
import authService from '../services/authService';
import { User } from '../types';

interface AuthContextType {
  currentUser: User | null;
  loading: boolean;
  login: (email: string, password: string) => Promise<User | null>;
  register: (email: string, password: string, firstName: string, lastName: string) => Promise<User | null>;
  logout: () => void;
}

const AuthContext = createContext<AuthContextType>({
  currentUser: null,
  loading: false,
  login: async () => null,
  register: async () => null,
  logout: () => { },
});

export const useAuth = () => useContext(AuthContext);

interface AuthProviderProps {
  children: ReactNode;
}

export const AuthProvider: React.FC<AuthProviderProps> = ({ children }) => {
  const [currentUser, setCurrentUser] = useState<User | null>(null);
  const [loading, setLoading] = useState<boolean>(true);
  const [initialCheckDone, setInitialCheckDone] = useState<boolean>(false);
  const navigate = useNavigate();
  const toast = useToast();

  // Check if user is authenticated on mount
  useEffect(() => {
    const checkAuth = async () => {
      try {
        if (authService.isAuthenticated()) {
          const user = authService.getCurrentUser();
          setCurrentUser(user);
        }
      } catch (error) {
        console.error('Authentication check failed:', error);
        // Clear invalid auth data
        authService.logout();
      } finally {
        setLoading(false);
        setInitialCheckDone(true);
      }
    };

    checkAuth();
  }, []);

  // Test backend connection when component mounts
  useEffect(() => {
    const testBackendConnection = async () => {
      if (!initialCheckDone) return;

      try {
        const isConnected = await authService.testConnection();
        if (!isConnected) {
          toast({
            title: 'Connection issue',
            description: 'Could not connect to the server. Some features may not work properly.',
            status: 'warning',
            duration: 10000,
            isClosable: true,
            position: 'top-right',
          });
        }
      } catch (error) {
        console.error('Backend connection test failed:', error);
      }
    };

    testBackendConnection();
  }, [initialCheckDone, toast]);

  const login = async (email: string, password: string): Promise<User | null> => {
    setLoading(true);
    try {
      const user = await authService.login(email, password);
      setCurrentUser(user);
      navigate('/');
      toast({
        title: 'Welcome back!',
        description: `You've successfully signed in.`,
        status: 'success',
        duration: 5000,
        isClosable: true,
      });
      return user;
    } catch (error: any) {
      const errorMessage = error.response?.data?.message || 'Invalid email or password';
      toast({
        title: 'Login failed',
        description: errorMessage,
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
      return null;
    } finally {
      setLoading(false);
    }
  };

  const register = async (
    email: string,
    password: string,
    firstName: string,
    lastName: string
  ): Promise<User | null> => {
    setLoading(true);
    try {
      const user = await authService.register(email, password, firstName, lastName);
      setCurrentUser(user);
      navigate('/');
      toast({
        title: 'Account created!',
        description: 'Your account has been successfully created.',
        status: 'success',
        duration: 5000,
        isClosable: true,
      });
      return user;
    } catch (error: any) {
      const errorMessage = error.response?.data?.message || 'Registration failed. Please try again.';
      toast({
        title: 'Registration failed',
        description: errorMessage,
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
      return null;
    } finally {
      setLoading(false);
    }
  };

  const logout = () => {
    authService.logout();
    setCurrentUser(null);
    navigate('/login');
    toast({
      title: 'Logged out',
      description: 'You have been successfully logged out.',
      status: 'info',
      duration: 3000,
      isClosable: true,
    });
  };

  const value = {
    currentUser,
    loading,
    login,
    register,
    logout,
  };

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
};

// Source: contexts\TripContext.tsx
import React, { createContext, useContext, useState, ReactNode } from 'react';
import { Trip, Image } from '../types';
import tripService from '../services/tripService';
import imageService from '../services/imageService';
import { useToast } from '@chakra-ui/react';

interface TripContextType {
  // Trips state
  trips: Trip[];
  currentTrip: Trip | null;
  isLoading: boolean;
  error: string | null;

  // Trip images
  tripImages: Image[];
  isImagesLoading: boolean;

  // Actions
  fetchTrips: () => Promise<Trip[]>;
  fetchTrip: (tripId: string) => Promise<Trip | null>;
  fetchTripImages: (tripId: string) => Promise<Image[]>;
  createTrip: (tripData: Omit<Trip, "id" | "createdAt">) => Promise<Trip | null>;
  updateTrip: (tripId: string, tripData: Partial<Trip>) => Promise<Trip | null>;
  deleteTrip: (tripId: string) => Promise<boolean>;
  uploadImages: (files: File[], tripId: string, onProgress?: (progress: number) => void) => Promise<Image[]>;
  deleteImage: (imageId: string) => Promise<boolean>;
  generateShareLink: (tripId: string) => Promise<{ shareId: string }>;
}

const TripContext = createContext<TripContextType>({
  trips: [],
  currentTrip: null,
  isLoading: false,
  error: null,
  tripImages: [],
  isImagesLoading: false,
  fetchTrips: async () => [],
  fetchTrip: async () => null,
  fetchTripImages: async () => [],
  createTrip: async () => null,
  updateTrip: async () => null,
  deleteTrip: async () => false,
  uploadImages: async () => [],
  deleteImage: async () => false,
  generateShareLink: async () => ({ shareId: '' }),
});

export const useTrip = () => useContext(TripContext);

interface TripProviderProps {
  children: ReactNode;
}

export const TripProvider: React.FC<TripProviderProps> = ({ children }) => {
  const [trips, setTrips] = useState<Trip[]>([]);
  const [currentTrip, setCurrentTrip] = useState<Trip | null>(null);
  const [isLoading, setIsLoading] = useState<boolean>(false);
  const [error, setError] = useState<string | null>(null);
  const [tripImages, setTripImages] = useState<Image[]>([]);
  const [isImagesLoading, setIsImagesLoading] = useState<boolean>(false);

  const toast = useToast();

  const fetchTrips = async () => {
    setIsLoading(true);
    setError(null);

    try {
      const data = await tripService.getTrips();
      setTrips(data);
      return data;
    } catch (err) {
      console.error('Error fetching trips:', err);
      setError('Failed to load trips. Please try again later.');
      toast({
        title: 'Error',
        description: 'Failed to load trips. Please try again.',
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
      return [];
    } finally {
      setIsLoading(false);
    }
  };

  const fetchTrip = async (tripId: string) => {
    setIsLoading(true);
    setError(null);

    try {
      const trip = await tripService.getTrip(tripId);
      setCurrentTrip(trip);
      return trip;
    } catch (err) {
      console.error(`Error fetching trip ${tripId}:`, err);
      setError('Failed to load trip details. Please try again later.');
      toast({
        title: 'Error',
        description: 'Failed to load trip details. Please try again.',
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
      return null;
    } finally {
      setIsLoading(false);
    }
  };

  const fetchTripImages = async (tripId: string) => {
    setIsImagesLoading(true);

    try {
      const images = await imageService.getImages(tripId);
      setTripImages(images);
      return images;
    } catch (err) {
      console.error(`Error fetching images for trip ${tripId}:`, err);
      toast({
        title: 'Error',
        description: 'Failed to load images. Please try again.',
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
      return [];
    } finally {
      setIsImagesLoading(false);
    }
  };

  const createTrip = async (tripData: Omit<Trip, "id" | "createdAt">) => {
    setIsLoading(true);

    try {
      const newTrip = await tripService.createTrip(tripData);
      setTrips(prevTrips => [...prevTrips, newTrip]);
      toast({
        title: 'Trip created',
        description: `${newTrip.name} has been created successfully.`,
        status: 'success',
        duration: 5000,
        isClosable: true,
      });
      return newTrip;
    } catch (err) {
      console.error('Error creating trip:', err);
      toast({
        title: 'Error',
        description: 'Failed to create trip. Please try again.',
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
      return null;
    } finally {
      setIsLoading(false);
    }
  };

  const updateTrip = async (tripId: string, tripData: Partial<Trip>) => {
    setIsLoading(true);

    try {
      const updatedTrip = await tripService.updateTrip(tripId, tripData);

      // Update trips list
      setTrips(prevTrips =>
        prevTrips.map(trip => trip.id === tripId ? { ...trip, ...updatedTrip } : trip)
      );

      // Update current trip if it's the one being edited
      if (currentTrip && currentTrip.id === tripId) {
        setCurrentTrip({ ...currentTrip, ...updatedTrip });
      }

      toast({
        title: 'Trip updated',
        description: `${updatedTrip.name} has been updated successfully.`,
        status: 'success',
        duration: 5000,
        isClosable: true,
      });

      return updatedTrip;
    } catch (err) {
      console.error(`Error updating trip ${tripId}:`, err);
      toast({
        title: 'Error',
        description: 'Failed to update trip. Please try again.',
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
      return null;
    } finally {
      setIsLoading(false);
    }
  };

  const deleteTrip = async (tripId: string) => {
    try {
      await tripService.deleteTrip(tripId);

      // Remove from trips list
      setTrips(prevTrips => prevTrips.filter(trip => trip.id !== tripId));

      // Clear current trip if it's the one being deleted
      if (currentTrip && currentTrip.id === tripId) {
        setCurrentTrip(null);
      }

      toast({
        title: 'Trip deleted',
        description: 'The trip has been deleted successfully.',
        status: 'success',
        duration: 5000,
        isClosable: true,
      });

      return true;
    } catch (err) {
      console.error(`Error deleting trip ${tripId}:`, err);
      toast({
        title: 'Error',
        description: 'Failed to delete trip. Please try again.',
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
      return false;
    }
  };

  const uploadImages = async (files: File[], tripId: string, onProgress?: (progress: number) => void) => {
    try {
      const uploadedImages = await imageService.uploadImages(files, tripId, [], onProgress);

      // Add new images to the current list
      setTripImages(prevImages => [...prevImages, ...uploadedImages]);

      toast({
        title: 'Images uploaded',
        description: `Successfully uploaded ${uploadedImages.length} images.`,
        status: 'success',
        duration: 3000,
        isClosable: true,
      });

      return uploadedImages;
    } catch (err) {
      console.error('Error uploading images:', err);
      toast({
        title: 'Error',
        description: 'Failed to upload images. Please try again.',
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
      return [];
    }
  };

  const deleteImage = async (imageId: string) => {
    try {
      await imageService.deleteImage(imageId);

      // Remove from images list
      setTripImages(prevImages => prevImages.filter(img => img.id !== imageId));

      toast({
        title: 'Image deleted',
        description: 'The image has been deleted successfully.',
        status: 'success',
        duration: 3000,
        isClosable: true,
      });

      return true;
    } catch (err) {
      console.error(`Error deleting image ${imageId}:`, err);
      toast({
        title: 'Error',
        description: 'Failed to delete the image. Please try again.',
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
      return false;
    }
  };

  const generateShareLink = async (tripId: string) => {
    try {
      const response = await tripService.generateShareLink(tripId);
      return response;
    } catch (err) {
      console.error(`Error generating share link for trip ${tripId}:`, err);
      toast({
        title: 'Error',
        description: 'Failed to generate share link. Please try again.',
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
      return { shareId: '' };
    }
  };

  // Provide all the values and functions to the context
  const value = {
    trips,
    currentTrip,
    isLoading,
    error,
    tripImages,
    isImagesLoading,
    fetchTrips,
    fetchTrip,
    fetchTripImages,
    createTrip,
    updateTrip,
    deleteTrip,
    uploadImages,
    deleteImage,
    generateShareLink,
  };

  return <TripContext.Provider value={value}>{children}</TripContext.Provider>;
};

export default TripProvider;

// Source: pages\HomePage.tsx
// HomePage.tsx - Main component
import React, { useEffect, useState } from 'react';
import { Box } from '@chakra-ui/react';
import { Trip } from '../types';
import tripService from '../services/tripService';
import { useAuth } from '../contexts/AuthContext';
import HeroSection from '../components/sections/HeroSection';
import RecentTripsSection from '../components/sections/RecentTripsSection';
import FeaturesSection from '../components/sections/FeaturesSection';
import CTASection from '../components/sections/CTASection';

const HomePage: React.FC = () => {
  const [recentTrips, setRecentTrips] = useState<Trip[]>([]);
  const [loading, setLoading] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);
  const { currentUser } = useAuth();

  useEffect(() => {
    const fetchRecentTrips = async () => {
      if (!currentUser) {
        setLoading(false);
        return;
      }

      try {
        setLoading(true);
        setError(null);
        const trips = await tripService.getTrips();
        // Sort trips by date (most recent first) and take only the first 4
        const sortedTrips = trips
          .sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())
          .slice(0, 4);
        setRecentTrips(sortedTrips);
      } catch (err) {
        console.error('Error fetching recent trips:', err);
        setError('Failed to load recent trips. Please try again later.');
      } finally {
        setLoading(false);
      }
    };

    fetchRecentTrips();
  }, [currentUser]);

  return (
    <Box>
      {/* Hero Section - Shown to everyone */}
      <HeroSection />

      {/* Recent Trips Section - Only shown to logged in users */}
      {currentUser && (
        <RecentTripsSection
          trips={recentTrips}
          loading={loading}
          error={error}
        />
      )}

      {/* Features Section - Shown to everyone */}
      <FeaturesSection />

      {/* Call to Action Section - Only shown to non-logged in users */}
      {!currentUser && <CTASection />}
    </Box>
  );
};

export default HomePage;

// Source: pages\NotFoundPage.tsx
import React from 'react';
import { Heading, Text, Button, Flex } from '@chakra-ui/react';
import { Link as RouterLink } from 'react-router-dom';

const NotFoundPage: React.FC = () => {
    return (
        <Flex
            minH="calc(100vh - 160px)"
            align="center"
            justify="center"
            direction="column"
            py={10}
        >
            <Heading as="h1" size="2xl" mb={4}>
                404
            </Heading>
            <Text fontSize="xl" mb={6} textAlign="center">
                Oops! The page you're looking for isn't on our map.
            </Text>
            <Button
                as={RouterLink}
                to="/"
                colorScheme="brand"
                size="lg"
            >
                Return to Home
            </Button>
        </Flex>
    );
};

export default NotFoundPage;

// Source: pages\ProfilePage.tsx


// Source: services\api.ts
import axios, { AxiosError, AxiosRequestConfig, AxiosResponse } from 'axios';

// Create an axios instance with default config
const api = axios.create({
  baseURL: import.meta.env.VITE_API_URL ? `${import.meta.env.VITE_API_URL}/api` : 'http://localhost:7051/api',
  headers: {
    'Content-Type': 'application/json',
  }
});

// Request interceptor to add auth token
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('token');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => Promise.reject(error)
);

// Response interceptor for error handling
api.interceptors.response.use(
  (response: AxiosResponse) => response,
  (error: AxiosError) => {
    if (error.response) {
      // The request was made and the server responded with a status code
      console.error('Server error:', error.response.status, error.response.data);
    } else if (error.request) {
      // The request was made but no response was received
      console.error('No response received:', error.request);
    } else {
      // Something happened in setting up the request
      console.error('Request error:', error.message);
    }

    // Handle specific errors
    if (error.response?.status === 401) {
      localStorage.removeItem('token');
      localStorage.removeItem('user');
      window.location.href = '/login';
    }

    return Promise.reject(error);
  }
);

// Type-safe wrapper for API methods
export const apiService = {
  get: <T>(url: string, config?: AxiosRequestConfig) =>
    api.get<T>(url, config).then(response => response.data),

  post: <T>(url: string, data?: any, config?: AxiosRequestConfig) =>
    api.post<T>(url, data, config).then(response => response.data),

  put: <T>(url: string, data?: any, config?: AxiosRequestConfig) =>
    api.put<T>(url, data, config).then(response => response.data),

  patch: <T>(url: string, data?: any, config?: AxiosRequestConfig) =>
    api.patch<T>(url, data, config).then(response => response.data),

  delete: <T>(url: string, config?: AxiosRequestConfig) =>
    api.delete<T>(url, config).then(response => response.data),
};

export default api;

// Source: services\authService.ts
import { apiService } from './api';
import { jwtDecode } from 'jwt-decode';
import { User } from '../types';

// In types/index.ts
interface AuthResponse {
  userId: string;
  token: string;
  expiresAt: string;
  firstName: string;
  lastName: string;
  email: string;
  role: string;
}

interface JwtPayload {
  sub: string;
  email: string;
  role: string;
  exp: number;
}

const authService = {
  register: async (email: string, password: string, firstName: string, lastName: string) => {
    try {
      console.log('Attempting registration with:', { email, firstName, lastName });
      const response = await apiService.post<AuthResponse>('/auth/register', {
        email,
        password,
        firstName,
        lastName
      });
      console.log('Registration successful, token received');
      
      // Map the response to a User object
      const user: User = {
        id: response.userId,
        email: response.email,
        firstName: response.firstName,
        lastName: response.lastName,
        role: response.role as 'USER' | 'SYSTEM_ADMIN',
        storageQuota: 10240, // Default values
        aiQuota: 50
      };
      
      console.log('Saving user to localStorage:', user);
      localStorage.setItem('token', response.token);
      localStorage.setItem('user', JSON.stringify(user));
      
      return user;
    } catch (error) {
      console.error('Registration failed:', error);
      throw error;
    }
  },
  
  login: async (email: string, password: string) => {
    try {
      console.log('Attempting login with:', { email });
      const response = await apiService.post<AuthResponse>('/auth/login', {
        email,
        password
      });
      console.log('Login successful, token received');
      
      // Map the response to a User object
      const user: User = {
        id: response.userId,
        email: response.email,
        firstName: response.firstName,
        lastName: response.lastName,
        role: response.role as 'USER' | 'SYSTEM_ADMIN',
        storageQuota: 10240, // Default values
        aiQuota: 50
      };
      
      console.log('Saving user to localStorage:', user);
      localStorage.setItem('token', response.token);
      localStorage.setItem('user', JSON.stringify(user));
      
      return user;
    } catch (error) {
      console.error('Login failed:', error);
      throw error;
    }
  },

  logout: () => {
    localStorage.removeItem('token');
    localStorage.removeItem('user');
  },

  // In authService.ts
  getCurrentUser: (): User | null => {
    const userStr = localStorage.getItem('user');
    console.log('getCurrentUser - userStr from localStorage:', userStr);
    
    if (!userStr) return null;
  
    try {
      const user = JSON.parse(userStr);
      console.log('getCurrentUser - parsed user:', user);
      return user;
    } catch (error) {
      console.error('Error parsing user from localStorage:', error);
      localStorage.removeItem('user'); // Remove invalid data
      return null;
    }
  },

  isAuthenticated: (): boolean => {
    const token = localStorage.getItem('token');
    if (!token) return false;

    try {
      const decoded = jwtDecode<JwtPayload>(token);
      // Check if token is expired
      return decoded.exp * 1000 > Date.now();
    } catch {
      return false;
    }
  },
  // Add this function to authService
  testConnection: async () => {
    try {
      await apiService.get('/health'); // Assumes you have a /health endpoint
      return true;
    } catch (error) {
      console.error('Backend connection test failed:', error);
      return false;
    }
  }
};

export default authService;

// Source: services\imageService.ts
import { apiService } from './api';
import { Image } from '../types';
import axios from 'axios';

interface GenerateAiImageRequest {
    prompt: string;
    style?: string;
    tripId?: string;
}

const imageService = {
    // Get all images for a specific trip
    getImages: async (tripId: string) => {
        try {
            return await apiService.get<Image[]>(`/images?tripId=${tripId}`);
        } catch (error) {
            console.error(`Failed to fetch images for trip ${tripId}:`, error);
            throw error;
        }
    },

    // Get a specific image by ID
    getImage: async (id: string) => {
        try {
            return await apiService.get<Image>(`/images/${id}`);
        } catch (error) {
            console.error(`Failed to fetch image ${id}:`, error);
            throw error;
        }
    },

    // Upload one or more images to a trip
    uploadImages: async (files: File[], tripId: string, tags: string[], onProgress?: (progress: number) => void) => {
        try {
            const formData = new FormData();

            // שמור על האותיות גדולות בהתחלה
            formData.append('TripId', tripId);  // T גדולה

            // Append each file to the form data
            Array.from(files).forEach(file => {
                formData.append('Files', file);  // F גדולה
            });

            // הוסף לוג של תוכן ה-tags לפני שמנסים לשלוח אותם
            console.log('Tags:', tags);

            // הוסף את תגיות ה-`Tags` אם זה מערך
            if (Array.isArray(tags)) {
                tags.forEach(tag => {
                    console.log(`Appending tag: ${tag}`); // לוג של כל תגית שמוסיפים
                    formData.append('Tags', tag);
                });
            } else {
                console.error('Tags is not an array:', tags); // לוג במקרה שה-`tags` לא מערך
            }

            // הוסף לוג לדיבוג כדי לראות את כל תוכן ה-FormData
            console.log('FormData contents:');
            for (let [key, value] of formData.entries()) {
                console.log(`${key}: `, value instanceof File ? `File: ${value.name} (${value.size} bytes)` : value);
            }

            const baseURL = import.meta.env.VITE_API_URL ?
                `${import.meta.env.VITE_API_URL}/api` :
                'http://localhost:7051/api';

            const token = localStorage.getItem('token');
            if (!token) {
                throw new Error('Authentication token not found. Please log in again.');
            }

            const response = await axios.post(
                `${baseURL}/images/upload`,
                formData,
                {
                    headers: {
                        'Authorization': `Bearer ${token}`,  // וודא שזה בפורמט הנכון עם רווח אחרי Bearer
                    },
                    onUploadProgress: (progressEvent: any) => {
                        if (onProgress && progressEvent.total) {
                            const percentCompleted = Math.round((progressEvent.loaded * 100) / progressEvent.total);
                            onProgress(percentCompleted);
                        }
                    }
                }
            );

            return response.data;
        } catch (error) {
            console.error('Failed to upload images:', error);
            if (axios.isAxiosError(error)) {
                if (error.response) {
                    console.error('Error data:', error.response.data);
                    console.error('Error details:', error.response.data.errors);
                    console.error('Error status:', error.response.status);
                    console.error('Error headers:', error.response.headers);
                }
            }
            throw error;
        }
    },

    // Delete an image
    deleteImage: async (id: string) => {
        try {
            return await apiService.delete<void>(`/images/${id}`);
        } catch (error) {
            console.error(`Failed to delete image ${id}:`, error);
            throw error;
        }
    },

    // Generate an AI image
    generateAiImage: async (request: GenerateAiImageRequest) => {
        try {
            return await apiService.post<Image>('/ai-images', request);
        } catch (error) {
            console.error('Failed to generate AI image:', error);
            throw error;
        }
    },

    // Update image metadata (e.g., adding tags)
    updateImageMetadata: async (id: string, metadata: any) => {
        try {
            return await apiService.patch<Image>(`/images/${id}`, metadata);
        } catch (error) {
            console.error(`Failed to update image metadata for ${id}:`, error);
            throw error;
        }
    },

    // Get remaining AI image quota for the current user
    getAiQuota: async () => {
        try {
            return await apiService.get<{ remaining: number, total: number }>('/images/ai-quota');
        } catch (error) {
            console.error('Failed to fetch AI quota:', error);
            throw error;
        }
    }
};

export default imageService;

// Source: services\tripService.ts
import { apiService } from './api';
import { Trip } from '../types';

const tripService = {
    // Get all trips for the current user
    getTrips: async () => {
        try {
            return await apiService.get<Trip[]>('/trips');
        } catch (error) {
            console.error('Failed to fetch trips:', error);
            throw error;
        }
    },

    // Get a specific trip by ID
    getTrip: async (id: string) => {
        try {
            return await apiService.get<Trip>(`/trips/${id}`);
        } catch (error) {
            console.error(`Failed to fetch trip ${id}:`, error);
            throw error;
        }
    },

    // Create a new trip
    createTrip: async (tripData: Omit<Trip, 'id' | 'createdAt'>) => {
        try {
            return await apiService.post<Trip>('/trips', tripData);
        } catch (error) {
            console.error('Failed to create trip:', error);
            throw error;
        }
    },

    // Update an existing trip
    updateTrip: async (id: string, tripData: Partial<Omit<Trip, 'id' | 'createdAt'>>) => {
        try {
            return await apiService.put<Trip>(`/trips/${id}`, tripData);
        } catch (error) {
            console.error(`Failed to update trip ${id}:`, error);
            throw error;
        }
    },

    // Delete a trip
    deleteTrip: async (id: string) => {
        try {
            return await apiService.delete<void>(`/trips/${id}`);
        } catch (error) {
            console.error(`Failed to delete trip ${id}:`, error);
            throw error;
        }
    },

    // Generate a sharing link for a trip
    generateShareLink: async (id: string) => {
        try {
            return await apiService.post<{ shareId: string }>(`/trips/${id}/share`);
        } catch (error) {
            console.error(`Failed to generate share link for trip ${id}:`, error);
            throw error;
        }
    },

    // Get a trip by share ID (for public access)
    getSharedTrip: async (shareId: string) => {
        try {
            return await apiService.get<Trip>(`/trips/shared/${shareId}`);
        } catch (error) {
            console.error(`Failed to fetch shared trip ${shareId}:`, error);
            throw error;
        }
    }
};

export default tripService;

// Source: theme\index.ts
// src/theme/index.ts
import { extendTheme, ThemeConfig } from '@chakra-ui/react';

// הגדרת תצורה לתמיכה במצב חשוך
const config: ThemeConfig = {
  initialColorMode: 'light',
  useSystemColorMode: true, // אם רוצים שהאפליקציה תשתמש בהגדרת המערכת
};

const theme = extendTheme({
  config,
  colors: {
    brand: {
      50: '#e6f7ff',
      100: '#b3e0ff',
      200: '#80c9ff',
      300: '#4db2ff',
      400: '#1a9bff',
      500: '#0084e6',
      600: '#0068b4',
      700: '#004d82',
      800: '#003350',
      900: '#001a1f',
    },
  },
  fonts: {
    heading: '"Open Sans", sans-serif',
    body: '"Open Sans", sans-serif',
  },
  components: {
    Button: {
      baseStyle: {
        fontWeight: 'semibold',
        borderRadius: 'md',
      },
      variants: {
        solid: {
          bg: 'brand.500',
          color: 'white',
          _hover: {
            bg: 'brand.600',
          },
        },
      },
    },
    Card: {
      baseStyle: (props: { colorMode: string }) => ({
        container: {
          bg: props.colorMode === 'dark' ? 'gray.800' : 'white',
          borderColor: props.colorMode === 'dark' ? 'gray.700' : 'gray.200',
        }
      })
    }
  },
  styles: {
    global: (props: { colorMode: string }) => ({
      body: {
        bg: props.colorMode === 'dark' ? 'gray.900' : 'gray.50',
        color: props.colorMode === 'dark' ? 'white' : 'gray.800',
      },
    }),
  },
});

export default theme;

// Source: types\index.ts
// User types
export interface User {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  role: 'USER' | 'SYSTEM_ADMIN';
  storageQuota: number;
  aiQuota: number;
}

export interface LoginFormData {
  email: string;
  password: string;
}

export interface RegisterFormData {
  email: string;
  password: string;
  confirmPassword: string;
  firstName: string;
  lastName: string;
}

export interface FormErrors {
  [key: string]: string;
}

// Trip types
export interface Trip {
  id: string;
  name: string;
  description?: string;
  startDate: string;
  endDate: string;
  locationName?: string;
  latitude?: number;
  longitude?: number;
  shareId?: string;
  createdAt: string;
}

// Image types
// In your types.ts file
export interface Image {
  id: string;
  fileName: string;
  filePath: string;
  fileSize: number;
  mimeType: string;
  fileUrl: string; // Add this property
  takenAt: string | null;
  tripId: string;
  tripName: string;
  isAiGenerated: boolean;
  aiPrompt: string | null;
  aiStyle: string | null;
  userId: string;
  createdAt: string;
  tags: any[] | null;
}

// Tag types
export interface Tag {
  id: string;
  name: string;
}

// Source: utils\imageUtils.ts
// src/utils/imageUtils.ts
import { Image } from '../types';

export const getImageUrl = (image: Image): string => {
  if (!image) {
    return '/images/placeholder.jpg';
  }
  
  const apiBaseUrl = import.meta.env.VITE_API_URL || '';
  // Use the /api/images/{id}/content endpoint pattern from your Swagger
  return `${apiBaseUrl.replace(/\/$/, '')}/api/images/${image.id}/content`;
};

// Source: components\auth\LoginForm.tsx
import React, { useState } from 'react';
import { Link as RouterLink } from 'react-router-dom';
import {
  Box,
  Button,
  FormControl,
  FormLabel,
  Input,
  FormErrorMessage,
  VStack,
  Heading,
  Text,
  Link,
  Flex,
  Image,
  useColorModeValue,
} from '@chakra-ui/react';
import { useAuth } from '../../contexts/AuthContext';
import { LoginFormData, FormErrors } from '../../types';

const LoginForm: React.FC = () => {
  const [formData, setFormData] = useState<LoginFormData>({
    email: '',
    password: '',
  });
  const [errors, setErrors] = useState<FormErrors>({});
  const { login, loading } = useAuth();
  const bgColor = useColorModeValue('white', 'gray.800');
  const borderColor = useColorModeValue('gray.200', 'gray.700');

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setFormData({ ...formData, [name]: value });

    // Clear errors when user starts typing
    if (errors[name]) {
      setErrors({ ...errors, [name]: '' });
    }
  };

  const validateForm = (): boolean => {
    const newErrors: FormErrors = {};
    if (!formData.email) {
      newErrors.email = 'Email is required';
    } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
      newErrors.email = 'Email is invalid';
    }
    if (!formData.password) {
      newErrors.password = 'Password is required';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (!validateForm()) return;

    try {
      await login(formData.email, formData.password);
      // Remove this line - navigation is now handled in AuthContext
      // navigate('/');
    } catch (error) {
      // Error is handled by the AuthContext's toast notifications
    }
  };

  return (
    <Flex
      minH="100vh"
      align="center"
      justify="center"
      bg={useColorModeValue('gray.50', 'gray.900')}
    >
      <Box
        w="full"
        maxW="md"
        py={12}
        px={6}
        bg={bgColor}
        borderRadius="lg"
        boxShadow="lg"
        borderWidth="1px"
        borderColor={borderColor}
      >
        <VStack spacing={6} align="center" mb={8}>
          <Image src="/images/welcome-landscape.jpg" alt="Scenic travel destination with mountains and nature views" h="300px" />
          <Heading as="h1" size="xl" fontWeight="bold">
            Sign In
          </Heading>
          <Text fontSize="md" color="gray.600">
            Welcome back! Sign in to manage your travel memories
          </Text>
        </VStack>

        <form onSubmit={handleSubmit}>
          <VStack spacing={4}>
            <FormControl isInvalid={!!errors.email}>
              <FormLabel htmlFor="email">Email Address</FormLabel>
              <Input
                id="email"
                name="email"
                type="email"
                value={formData.email}
                onChange={handleChange}
                placeholder="Enter your email address"
                size="lg"
              />
              <FormErrorMessage>{errors.email}</FormErrorMessage>
            </FormControl>

            <FormControl isInvalid={!!errors.password}>
              <FormLabel htmlFor="password">Password</FormLabel>
              <Input
                id="password"
                name="password"
                type="password"
                value={formData.password}
                onChange={handleChange}
                placeholder="Enter your password"
                size="lg"
              />
              <FormErrorMessage>{errors.password}</FormErrorMessage>
            </FormControl>

            <Button
              type="submit"
              colorScheme="brand"
              size="lg"
              width="full"
              mt={4}
              isLoading={loading}
              loadingText="Signing in"
            >
              Sign In
            </Button>
          </VStack>
        </form>

        <Text mt={6} textAlign="center">
          Don't have an account?{' '}
          <Link as={RouterLink} to="/register" color="brand.500" fontWeight="semibold">
            Sign Up Now
          </Link>
        </Text>
      </Box>
    </Flex>
  );
};

export default LoginForm;

// Source: components\auth\RegisterForm.tsx
import React, { useState } from 'react';
import { Link as RouterLink } from 'react-router-dom';
import {
  Box,
  Button,
  FormControl,
  FormLabel,
  Input,
  FormErrorMessage,
  VStack,
  HStack,
  Heading,
  Text,
  Link,
  Checkbox,
  Flex,
  Image,
  useColorModeValue,
} from '@chakra-ui/react';
import { useAuth } from '../../contexts/AuthContext';
import { RegisterFormData, FormErrors } from '../../types';

const RegisterForm: React.FC = () => {
  const [formData, setFormData] = useState<RegisterFormData>({
    firstName: '',
    lastName: '',
    email: '',
    password: '',
    confirmPassword: '',
  });
  const [errors, setErrors] = useState<FormErrors>({});
  const [termsAccepted, setTermsAccepted] = useState<boolean>(false);
  const { register, loading } = useAuth();
  const bgColor = useColorModeValue('white', 'gray.800');
  const borderColor = useColorModeValue('gray.200', 'gray.700');

  const handleChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = e.target;
    setFormData({ ...formData, [name]: value });

    // Clear errors when user starts typing
    if (errors[name]) {
      setErrors({ ...errors, [name]: '' });
    }
  };

  const validateForm = (): boolean => {
    const newErrors: FormErrors = {};
    if (!formData.firstName) {
      newErrors.firstName = 'First name is required';
    }
    if (!formData.lastName) {
      newErrors.lastName = 'Last name is required';
    }
    if (!formData.email) {
      newErrors.email = 'Email is required';
    } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
      newErrors.email = 'Email is invalid';
    }
    if (!formData.password) {
      newErrors.password = 'Password is required';
    } else if (formData.password.length < 6) {
      newErrors.password = 'Password must be at least 8 characters';
    }
    if (formData.password !== formData.confirmPassword) {
      newErrors.confirmPassword = 'Passwords do not match';
    }
    if (!termsAccepted) {
      newErrors.terms = 'You must agree to the terms and conditions';
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (!validateForm()) return;

    try {
      await register(
        formData.email,
        formData.password,
        formData.firstName,
        formData.lastName
      );
      // Remove this line - navigation is now handled in AuthContext
      // navigate('/');
    } catch (error) {
      // Error is handled by the AuthContext's toast notifications
    }
  };

  return (
    <Flex
      minH="100vh"
      align="center"
      justify="center"
      bg={useColorModeValue('gray.50', 'gray.900')}
    >
      <Box
        w="full"
        maxW="md"
        py={12}
        px={6}
        bg={bgColor}
        borderRadius="lg"
        boxShadow="lg"
        borderWidth="1px"
        borderColor={borderColor}
      >
        <VStack spacing={6} align="center" mb={8}>
          <Image src="/images/journey1.jpg" alt="Start your journey with TravelMemories - Beautiful landscape view" h="300px" />
          <Heading as="h1" size="xl" fontWeight="bold">
            Create Account
          </Heading>
          <Text fontSize="md" color="gray.600">
            Sign up to start documenting your travel memories
          </Text>
        </VStack>

        <form onSubmit={handleSubmit}>
          <VStack spacing={4}>
            <HStack spacing={4} w="full">
              <FormControl isInvalid={!!errors.firstName}>
                <FormLabel htmlFor="firstName">First Name</FormLabel>
                <Input
                  id="firstName"
                  name="firstName"
                  value={formData.firstName}
                  onChange={handleChange}
                  placeholder="First name"
                  size="lg"
                />
                <FormErrorMessage>{errors.firstName}</FormErrorMessage>
              </FormControl>

              <FormControl isInvalid={!!errors.lastName}>
                <FormLabel htmlFor="lastName">Last Name</FormLabel>
                <Input
                  id="lastName"
                  name="lastName"
                  value={formData.lastName}
                  onChange={handleChange}
                  placeholder="Last name"
                  size="lg"
                />
                <FormErrorMessage>{errors.lastName}</FormErrorMessage>
              </FormControl>
            </HStack>

            <FormControl isInvalid={!!errors.email}>
              <FormLabel htmlFor="email">Email Address</FormLabel>
              <Input
                id="email"
                name="email"
                type="email"
                value={formData.email}
                onChange={handleChange}
                placeholder="Enter your email address"
                size="lg"
              />
              <FormErrorMessage>{errors.email}</FormErrorMessage>
            </FormControl>

            <FormControl isInvalid={!!errors.password}>
              <FormLabel htmlFor="password">Password</FormLabel>
              <Input
                id="password"
                name="password"
                type="password"
                value={formData.password}
                onChange={handleChange}
                placeholder="Create a password (at least 8 characters)"
                size="lg"
              />
              <FormErrorMessage>{errors.password}</FormErrorMessage>
            </FormControl>

            <FormControl isInvalid={!!errors.confirmPassword}>
              <FormLabel htmlFor="confirmPassword">Confirm Password</FormLabel>
              <Input
                id="confirmPassword"
                name="confirmPassword"
                type="password"
                value={formData.confirmPassword}
                onChange={handleChange}
                placeholder="Confirm your password"
                size="lg"
              />
              <FormErrorMessage>{errors.confirmPassword}</FormErrorMessage>
            </FormControl>

            <FormControl isInvalid={!!errors.terms}>
              <Checkbox
                colorScheme="brand"
                isChecked={termsAccepted}
                onChange={(e) => setTermsAccepted(e.target.checked)}
              >
                I agree to the{' '}
                <Link as={RouterLink} to="/terms" color="brand.500">
                  Terms of Service
                </Link>{' '}
                and{' '}
                <Link as={RouterLink} to="/privacy" color="brand.500">
                  Privacy Policy
                </Link>
              </Checkbox>
              <FormErrorMessage>{errors.terms}</FormErrorMessage>
            </FormControl>

            <Button
              type="submit"
              colorScheme="brand"
              size="lg"
              width="full"
              mt={4}
              isLoading={loading}
              loadingText="Creating Account"
            >
              Sign Up
            </Button>
          </VStack>
        </form>

        <Text mt={6} textAlign="center">
          Already have an account?{' '}
          <Link as={RouterLink} to="/login" color="brand.500" fontWeight="semibold">
            Sign In Here
          </Link>
        </Text>
      </Box>
    </Flex>
  );
};

export default RegisterForm;

// Source: components\common\AppLogo.tsx
import React from 'react';
import { Flex, Box, Text, useColorModeValue } from '@chakra-ui/react';

interface AppLogoProps {
  size?: string;
  showText?: boolean;
}

const AppLogo: React.FC<AppLogoProps> = ({ 
  size = "40px", 
  showText = true 
}) => {
  const logoColor = useColorModeValue('brand.500', 'brand.300');
  const textColor = useColorModeValue('brand.500', 'brand.300');
  
  return (
    <Flex align="center">
      <Box
        h={size}
        w={size}
        display="flex"
        alignItems="center"
        justifyContent="center"
        fontWeight="bold"
        color="white"
        bg={logoColor}
        borderRadius="md"
      >
        TM
      </Box>
      
      {showText && (
        <Text
          fontWeight="bold"
          fontSize="lg"
          color={textColor}
          ml={2}
        >
          TravelMemories
        </Text>
      )}
    </Flex>
  );
};

export default AppLogo;

// Source: components\common\DarkModeToggle.tsx
import React from 'react';
import { IconButton, useColorMode, useColorModeValue, Tooltip } from '@chakra-ui/react';
import { MoonIcon, SunIcon } from '@chakra-ui/icons';

const DarkModeToggle: React.FC = () => {
    const { toggleColorMode } = useColorMode();
    const SwitchIcon = useColorModeValue(MoonIcon, SunIcon);
    const buttonText = useColorModeValue('Switch to Dark Mode', 'Switch to Light Mode');

    return (
        <Tooltip label={buttonText} hasArrow placement="bottom">
            <IconButton
                aria-label={buttonText}
                icon={<SwitchIcon />}
                variant="ghost"
                onClick={toggleColorMode}
                size="md"
                borderRadius="md"
                _hover={{
                    bg: useColorModeValue('gray.200', 'gray.700'),
                }}
            />
        </Tooltip>
    );
};

export default DarkModeToggle;

// Source: components\common\ImagePlaceholder.tsx
import React from 'react';
import { Box, Flex, Text, Icon, useColorModeValue } from '@chakra-ui/react';
import { FaImage } from 'react-icons/fa';

interface ImagePlaceholderProps {
    text?: string;
    width?: string;
    height?: string;
    aspectRatio?: string;
}

const ImagePlaceholder: React.FC<ImagePlaceholderProps> = ({
    text = 'No Image',
    width = '100%',
    height = 'auto',
    aspectRatio = '1 / 1',
}) => {
    const bgColor = useColorModeValue('gray.100', 'gray.700');
    const textColor = useColorModeValue('gray.500', 'gray.300');
    const iconColor = useColorModeValue('gray.300', 'gray.500');

    return (
        <Box
            width={width}
            height={height}
            aspectRatio={aspectRatio}
            bg={bgColor}
            borderRadius="md"
        >
            <Flex
                height="100%"
                direction="column"
                alignItems="center"
                justifyContent="center"
                p={4}
            >
                <Icon as={FaImage} boxSize="2rem" color={iconColor} mb={2} />
                <Text
                    textAlign="center"
                    color={textColor}
                    fontSize="sm"
                    fontWeight="medium"
                    noOfLines={2}
                >
                    {text}
                </Text>
            </Flex>
        </Box>
    );
};

export default ImagePlaceholder;

// Source: components\common\LazyImage.tsx
import React, { useState, useEffect, useRef } from 'react';
import { 
  Box, 
  Skeleton, 
  useColorModeValue 
} from '@chakra-ui/react';
import { Image as ImageType } from '../../types';

interface LazyImageProps {
  src: string;
  alt: string;
  width?: string | number;
  height?: string | number;
  objectFit?: 'cover' | 'contain' | 'fill' | 'none' | 'scale-down';
  borderRadius?: string | number;
  onClick?: () => void;
  threshold?: number; // Intersection observer threshold
  fallbackSrc?: string;
  cursor?: string;
  paddingBottom?: string;
  image?: ImageType; // Optional image object to use with getImageUrl
}

const LazyImage: React.FC<LazyImageProps> = ({
  src,
  alt,
  width = '100%',
  height = 'auto',
  objectFit = 'cover',
  borderRadius = 'md',
  onClick,
  threshold = 0.1,
  fallbackSrc = '/images/placeholder.jpg',
  cursor,
  paddingBottom,
}) => {
  const [isLoaded, setIsLoaded] = useState(false);
  const [isVisible, setIsVisible] = useState(false);
  const [hasError, setHasError] = useState(false);
  const [imageSrc, setImageSrc] = useState<string | null>(null);
  const imageRef = useRef<HTMLDivElement>(null);
  
  const skeletonStartColor = useColorModeValue('gray.100', 'gray.700');
  const skeletonEndColor = useColorModeValue('gray.300', 'gray.600');

  // Create and use IntersectionObserver to detect when image is in viewport
  useEffect(() => {
    const observer = new IntersectionObserver(
      (entries) => {
        if (entries[0].isIntersecting) {
          setIsVisible(true);
          observer.disconnect();
        }
      },
      { threshold }
    );

    if (imageRef.current) {
      observer.observe(imageRef.current);
    }

    return () => {
      observer.disconnect();
    };
  }, [threshold]);

  // When image becomes visible, set the src
  useEffect(() => {
    if (isVisible) {
      setImageSrc(src);
    }
  }, [isVisible, src]);

  const handleLoad = () => {
    setIsLoaded(true);
  };

  const handleError = () => {
    setHasError(true);
    setImageSrc(fallbackSrc);
  };

  return (
    <Box
      ref={imageRef}
      position="relative"
      width={width}
      height={height}
      borderRadius={borderRadius}
      overflow="hidden"
      cursor={onClick ? 'pointer' : cursor || 'default'}
      onClick={onClick}
      paddingBottom={paddingBottom}
    >
      {(!isLoaded || !isVisible) && (
        <Skeleton
          position="absolute"
          top={0}
          left={0}
          width="100%"
          height="100%"
          startColor={skeletonStartColor}
          endColor={skeletonEndColor}
        />
      )}
      
      {imageSrc && (
        <Box
          as="img"
          src={imageSrc}
          alt={alt}
          width="100%"
          height="100%"
          objectFit={objectFit}
          position="absolute"
          top={0}
          left={0}
          opacity={isLoaded ? 1 : 0}
          transition="opacity 0.3s ease-in-out"
          onLoad={handleLoad}
          onError={handleError}
          title={alt}
        />
      )}
    </Box>
  );
};

export default LazyImage;

// Source: components\common\LoadingSpinner.tsx
import React from 'react';
import { Flex, Spinner, Text, VStack } from '@chakra-ui/react';

interface LoadingSpinnerProps {
  text?: string;
  size?: string;
}

const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({
  text = 'Loading...',
  size = 'xl'
}) => {
  return (
    <Flex justify="center" align="center" h="100%" minH="200px" w="100%">
      <VStack spacing={4}>
        <Spinner
          thickness="4px"
          speed="0.65s"
          emptyColor="gray.200"
          color="brand.500"
          size={size}
        />
        {text && <Text>{text}</Text>}
      </VStack>
    </Flex>
  );
};

export default LoadingSpinner;

// Source: components\common\OptimizedImage.tsx
import React, { useState, useEffect } from 'react';
import { 
  Box, 
  Skeleton, 
  AspectRatio,
  useColorModeValue 
} from '@chakra-ui/react';
import { Image as ImageType } from '../../types';

interface OptimizedImageProps {
  src: string;
  alt: string;
  lowQualitySrc?: string;
  fallbackSrc?: string;
  aspectRatio?: number;
  objectFit?: 'cover' | 'contain' | 'fill' | 'none' | 'scale-down';
  borderRadius?: string | number;
  height?: string | number;
  width?: string | number;
  onClick?: () => void;
  image?: ImageType; // Optional image object
}

const OptimizedImage: React.FC<OptimizedImageProps> = ({
  src,
  alt,
  lowQualitySrc,
  fallbackSrc = '/images/placeholder.jpg',
  aspectRatio = 1,
  objectFit = 'cover',
  borderRadius = 'md',
  height,
  width = '100%',
  onClick,
}) => {
  const [isLoaded, setIsLoaded] = useState(false);
  const [hasError, setHasError] = useState(false);
  const [actualSrc, setActualSrc] = useState<string>(src);
  
  const skeletonStartColor = useColorModeValue('gray.100', 'gray.700');
  const skeletonEndColor = useColorModeValue('gray.300', 'gray.600');

  // Reset loading state when src changes
  useEffect(() => {
    setIsLoaded(false);
    setHasError(false);
    setActualSrc(src);
  }, [src]);

  const handleLoad = () => {
    setIsLoaded(true);
  };

  const handleError = () => {
    setHasError(true);
    setActualSrc(fallbackSrc);
  };

  const renderImage = () => (
    <>
      {!isLoaded && (
        <Skeleton
          position="absolute"
          top={0}
          left={0}
          width="100%"
          height="100%"
          startColor={skeletonStartColor}
          endColor={skeletonEndColor}
          borderRadius={borderRadius}
        />
      )}
      
      {lowQualitySrc && !isLoaded && (
        <Box
          as="img"
          src={lowQualitySrc}
          position="absolute"
          top={0}
          left={0}
          width="100%"
          height="100%"
          objectFit={objectFit}
          opacity={0.7}
          filter="blur(10px)"
          transform="scale(1.05)"
          borderRadius={borderRadius}
        />
      )}
      
      <Box
        as="img"
        src={actualSrc}
        alt={alt}
        position="absolute"
        top={0}
        left={0}
        width="100%"
        height="100%"
        objectFit={objectFit}
        opacity={isLoaded ? 1 : 0}
        transition="opacity 0.3s ease-in-out"
        borderRadius={borderRadius}
        onLoad={handleLoad}
        onError={handleError}
        onClick={onClick}
        cursor={onClick ? "pointer" : "default"}
        title={alt}
      />
    </>
  );

  // If aspectRatio is provided, wrap in AspectRatio
  if (aspectRatio) {
    return (
      <AspectRatio ratio={aspectRatio} width={width} height={height} borderRadius={borderRadius} overflow="hidden">
        <Box position="relative" width="100%" height="100%">
          {renderImage()}
        </Box>
      </AspectRatio>
    );
  }

  // Otherwise, use a regular Box
  return (
    <Box position="relative" width={width} height={height} borderRadius={borderRadius} overflow="hidden">
      {renderImage()}
    </Box>
  );
};

export default OptimizedImage;

// Source: components\gallery\MasonryGrid.tsx
import React, { useState, useEffect } from 'react';
import { Box, SimpleGrid, useBreakpointValue } from '@chakra-ui/react';
import { Image as ImageType } from '../../types';
import LazyImage from '../common/LazyImage';
import { getImageUrl } from '../../utils/imageUtils';

interface MasonryGridProps {
  images: ImageType[];
  columns?: { base: number; sm: number; md: number; lg: number };
  spacing?: number;
  onImageClick?: (index: number) => void;
}

const MasonryGrid: React.FC<MasonryGridProps> = ({
  images,
  columns = { base: 1, sm: 2, md: 3, lg: 4 },
  spacing = 4,
  onImageClick
}) => {
  const [columnHeights, setColumnHeights] = useState<number[]>([]);
  const [imageLayouts, setImageLayouts] = useState<Array<{ aspectRatio: number; column: number }>>([]);
  const currentColumns = useBreakpointValue(columns) || columns.base;

  // Simulate image loading to calculate aspect ratios
  useEffect(() => {
    const loadImages = async () => {
      // Reset column heights
      const heights = Array(currentColumns).fill(0);
      
      // Calculate layouts based on image aspect ratios
      const layouts = await Promise.all(
        images.map(async (image) => {
          // Default aspect ratio if we can't determine it
          let aspectRatio = 1;
          
          try {
            // Create a promise to get the image dimensions
            const dimensions = await new Promise<{ width: number; height: number }>((resolve) => {
              const img = new Image();
              img.onload = () => {
                resolve({ width: img.width, height: img.height });
              };
              img.onerror = () => {
                resolve({ width: 1, height: 1 }); // Default 1:1 ratio on error
              };
              // Use the correct image URL here
              img.src = getImageUrl(image);
            });
            
            aspectRatio = dimensions.width / dimensions.height;
          } catch (error) {
            console.error('Error calculating image dimensions:', error);
          }
          
          // Find the shortest column
          const shortestColumn = heights.indexOf(Math.min(...heights));
          
          // Update the column height
          heights[shortestColumn] += 1 / aspectRatio;
          
          return { aspectRatio, column: shortestColumn };
        })
      );
      
      setColumnHeights(heights);
      setImageLayouts(layouts);
    };
    
    if (images.length > 0 && currentColumns > 0) {
      loadImages();
    }
  }, [images, currentColumns]);

  // Group images by column
  const columnGroups = Array.from({ length: currentColumns }, (_, i) => 
    images.filter((_, index) => imageLayouts[index]?.column === i)
  );

  return (
    <SimpleGrid columns={currentColumns} spacing={spacing}>
      {columnGroups.map((columnImages, columnIndex) => (
        <Box key={columnIndex}>
          {columnImages.map((image, imageIndex) => {
            const originalIndex = images.findIndex(img => img.id === image.id);
            const aspectRatio = imageLayouts[originalIndex]?.aspectRatio || 1;
            
            return (
              <Box 
                key={image.id} 
                mb={spacing}
                onClick={() => onImageClick && onImageClick(originalIndex)}
              >
                <LazyImage
                  src={getImageUrl(image)}
                  alt={image.fileName}
                  width="100%"
                  height={0}
                  paddingBottom={`${100 / aspectRatio}%`}
                  objectFit="cover"
                  cursor={onImageClick ? "pointer" : "default"}
                  borderRadius="md"
                />
              </Box>
            );
          })}
        </Box>
      ))}
    </SimpleGrid>
  );
};

export default MasonryGrid;

// Source: components\gallery\ResponsivePhotoGrid.tsx
import React, { useState, useEffect } from 'react';
import {
  Box,
  SimpleGrid,
  Modal,
  ModalOverlay,
  ModalContent,
  ModalCloseButton,
  Flex,
  IconButton,
  Text,
  Badge,
  useDisclosure,
  useBreakpointValue,
} from '@chakra-ui/react';
import { FaArrowLeft, FaArrowRight, FaRobot } from 'react-icons/fa';
import { format } from 'date-fns';
import { Image as ImageType } from '../../types';
import OptimizedImage from '../common/OptimizedImage';
import { getImageUrl } from '../../utils/imageUtils';

interface ResponsivePhotoGridProps {
  images: ImageType[];
  columns?: { base: number; sm: number; md: number; lg: number };
  spacing?: number;
  maxImages?: number;
  highlightFirst?: boolean;
}

const ResponsivePhotoGrid: React.FC<ResponsivePhotoGridProps> = ({
  images,
  columns = { base: 2, sm: 3, md: 4, lg: 5 },
  spacing = 4,
  maxImages = 12,
  highlightFirst = false,
}) => {
  const [currentIndex, setCurrentIndex] = useState<number | null>(null);
  const { isOpen, onOpen, onClose } = useDisclosure();
  const [visibleImages, setVisibleImages] = useState<ImageType[]>([]);
  const [hasMore, setHasMore] = useState(false);

  // Determine grid columns based on screen size
  const actualColumns = useBreakpointValue(columns) || columns.base;

  useEffect(() => {
    if (images.length > maxImages) {
      setVisibleImages(images.slice(0, maxImages));
      setHasMore(true);
    } else {
      setVisibleImages(images);
      setHasMore(false);
    }
  }, [images, maxImages]);

  const handleImageClick = (index: number) => {
    setCurrentIndex(index);
    onOpen();
  };

  const navigateImages = (direction: 'prev' | 'next') => {
    if (currentIndex === null || images.length === 0) return;

    if (direction === 'prev') {
      setCurrentIndex((prevIndex) =>
        prevIndex === null ? 0 : (prevIndex === 0 ? images.length - 1 : prevIndex - 1)
      );
    } else {
      setCurrentIndex((prevIndex) =>
        prevIndex === null ? 0 : (prevIndex === images.length - 1 ? 0 : prevIndex + 1)
      );
    }
  };

  const currentImage = currentIndex !== null ? images[currentIndex] : null;

  // Create a grid with first image larger if highlightFirst is true
  const renderGrid = () => {
    if (visibleImages.length === 0) {
      return <Text>No images to display</Text>;
    }

    if (highlightFirst && visibleImages.length > 1) {
      return (
        <Box>
          <Box mb={spacing} onClick={() => handleImageClick(0)}>
            <OptimizedImage
              src={getImageUrl(visibleImages[0])}
              alt={visibleImages[0].fileName}
              aspectRatio={16 / 9}
              objectFit="cover"
              width="100%"
              onClick={() => handleImageClick(0)}
            />
          </Box>
          <SimpleGrid columns={actualColumns} spacing={spacing}>
            {visibleImages.slice(1).map((image, idx) => (
              <Box key={image.id} position="relative">
                <OptimizedImage
                  src={getImageUrl(image)}
                  alt={image.fileName}
                  aspectRatio={1}
                  objectFit="cover"
                  onClick={() => handleImageClick(idx + 1)}
                />
                {image.isAiGenerated && (
                  <Badge
                    position="absolute"
                    top={2}
                    left={2}
                    colorScheme="purple"
                    fontSize="xs"
                    px={2}
                    py={1}
                    borderRadius="md"
                  >
                    AI
                  </Badge>
                )}
              </Box>
            ))}
          </SimpleGrid>
        </Box>
      );
    }

    // Regular grid for all images
    return (
      <SimpleGrid columns={actualColumns} spacing={spacing}>
        {visibleImages.map((image, idx) => (
          <Box key={image.id} position="relative">
            <OptimizedImage
              src={getImageUrl(image)}
              alt={image.fileName}
              aspectRatio={1}
              objectFit="cover"
              onClick={() => handleImageClick(idx)}
            />
            {image.isAiGenerated && (
              <Badge
                position="absolute"
                top={2}
                left={2}
                colorScheme="purple"
                fontSize="xs"
                px={2}
                py={1}
                borderRadius="md"
              >
                AI
              </Badge>
            )}
          </Box>
        ))}
      </SimpleGrid>
    );
  };

  return (
    <Box>
      {renderGrid()}

      {/* Image viewer modal */}
      <Modal isOpen={isOpen} onClose={onClose} size="full" isCentered>
        <ModalOverlay bg="blackAlpha.900" />
        <ModalContent bg="transparent" boxShadow="none" maxW="100vw" maxH="100vh">
          <ModalCloseButton color="white" zIndex={2} />

          <Flex
            justify="center"
            align="center"
            height="100vh"
            position="relative"
            onClick={onClose}
          >
            {/* Navigation buttons */}
            <IconButton
              aria-label="Previous image"
              icon={<FaArrowLeft />}
              position="absolute"
              left={4}
              onClick={(e) => {
                e.stopPropagation();
                navigateImages('prev');
              }}
              colorScheme="whiteAlpha"
              variant="ghost"
              fontSize="2xl"
              zIndex={1}
            />

            <IconButton
              aria-label="Next image"
              icon={<FaArrowRight />}
              position="absolute"
              right={4}
              onClick={(e) => {
                e.stopPropagation();
                navigateImages('next');
              }}
              colorScheme="whiteAlpha"
              variant="ghost"
              fontSize="2xl"
              zIndex={1}
            />

            {/* Current image */}
            {currentImage && (
              <Box
                maxW="90vw"
                maxH="90vh"
                onClick={(e) => e.stopPropagation()}
              >
                <Box
                  as="img"
                  src={getImageUrl(currentImage)}
                  alt={currentImage.fileName}
                  maxH="80vh"
                  maxW="90vw"
                  objectFit="contain"
                  borderRadius="md"
                />

                {/* Image info */}
                <Box
                  bg="blackAlpha.700"
                  p={3}
                  borderRadius="md"
                  mt={2}
                  color="white"
                >
                  <Flex justify="space-between" align="center">
                    <Text fontSize="md" fontWeight="medium">
                      {currentImage.fileName}
                    </Text>

                    {currentImage.isAiGenerated && (
                      <Badge colorScheme="purple" display="flex" alignItems="center" gap={1}>
                        <FaRobot size="0.8em" /> AI Generated
                      </Badge>
                    )}
                  </Flex>

                  {currentImage.takenAt && (
                    <Text fontSize="sm" mt={1}>
                      Taken on {format(new Date(currentImage.takenAt), 'MMMM d, yyyy')}
                    </Text>
                  )}

                  {currentImage.isAiGenerated && currentImage.aiPrompt && (
                    <Text fontSize="sm" mt={1}>
                      <strong>Prompt:</strong> {currentImage.aiPrompt}
                    </Text>
                  )}
                </Box>
              </Box>
            )}
          </Flex>
        </ModalContent>
      </Modal>
    </Box>
  );
};

export default ResponsivePhotoGrid;

// Source: components\layout\Footer.tsx
import React from 'react';
import { Link as RouterLink } from 'react-router-dom';
import {
  Box,
  Container,
  Stack,
  SimpleGrid,
  Text,
  Link,
  useColorModeValue,
} from '@chakra-ui/react';
import AppLogo from '../common/AppLogo';

interface ListHeaderProps {
  children: React.ReactNode;
}

const ListHeader: React.FC<ListHeaderProps> = ({ children }) => {
  return (
    <Text fontWeight="bold" fontSize="lg" mb={2}>
      {children}
    </Text>
  );
};

const Footer: React.FC = () => {
  const currentYear = new Date().getFullYear();
  const bg = useColorModeValue('gray.50', 'gray.900');
  const borderColor = useColorModeValue('gray.200', 'gray.700');

  return (
    <Box
      bg={bg}
      color={useColorModeValue('gray.700', 'gray.200')}
      borderTop="1px"
      borderColor={borderColor}
    >
      <Container as={Stack} maxW="6xl" py={10}>
        <SimpleGrid columns={{ base: 1, sm: 2, md: 4 }} spacing={8}>
          <Stack align="flex-start">
            <AppLogo />
            <Text fontSize="sm" color="gray.500" mt={4}>
              Create, manage, and share your travel memories with ease.
            </Text>
          </Stack>

          <Stack align="flex-start">
            <ListHeader>Features</ListHeader>
            <Link as={RouterLink} to="#">Photo Management</Link>
            <Link as={RouterLink} to="#">AI Image Generation</Link>
            <Link as={RouterLink} to="#">Interactive Maps</Link>
            <Link as={RouterLink} to="#">Trip Sharing</Link>
          </Stack>

          <Stack align="flex-start">
            <ListHeader>Quick Links</ListHeader>
            <Link as={RouterLink} to="/">Home</Link>
            <Link as={RouterLink} to="/trips">My Trips</Link>
            <Link as={RouterLink} to="/trips/new">Create New Trip</Link>
          </Stack>

          <Stack align="flex-start">
            <ListHeader>Legal</ListHeader>
            <Link as={RouterLink} to="/terms">Terms of Service</Link>
            <Link as={RouterLink} to="/privacy">Privacy Policy</Link>
          </Stack>
        </SimpleGrid>
      </Container>

      <Box
        borderTopWidth={1}
        borderColor={borderColor}
        py={4}
      >
        <Text pt={2} fontSize="sm" textAlign="center">
          &copy; {currentYear} TravelMemories. All rights reserved.
        </Text>
      </Box>
    </Box>
  );
};

export default Footer;

// Source: components\layout\Header.tsx
import React from 'react';
import { Link as RouterLink } from 'react-router-dom';
import {
  Box,
  Flex,
  Text,
  Button,
  Stack,
  Collapse,
  Link,
  useColorModeValue,
  useDisclosure,
  Container,
  HStack,
  IconButton,
  Menu,
  MenuButton,
  MenuList,
  MenuItem,
  MenuDivider,
  Avatar,
} from '@chakra-ui/react';
import { HamburgerIcon, CloseIcon, ChevronDownIcon } from '@chakra-ui/icons';
import { FaPlus } from 'react-icons/fa';
import { useAuth } from '../../contexts/AuthContext';
import DarkModeToggle from '../common/DarkModeToggle';
import AppLogo from '../common/AppLogo';

const Header: React.FC = () => {
  const { isOpen, onToggle } = useDisclosure();
  const { currentUser, logout } = useAuth();

  const backgroundColor = useColorModeValue('white', 'gray.800');
  const borderColor = useColorModeValue('gray.200', 'gray.700');
  const textColor = useColorModeValue('gray.600', 'gray.200');
  const brandColor = useColorModeValue('brand.500', 'brand.400');
  const hoverBgColor = useColorModeValue('gray.100', 'gray.700');

  return (
    <Box
      as="header"
      bg={backgroundColor}
      borderBottom={1}
      borderStyle={'solid'}
      borderColor={borderColor}
      boxShadow={'sm'}
      position="sticky"
      top={0}
      zIndex={20} // Increased z-index to ensure it's above other content
    >
      <Container maxW="container.xl">
        <Flex 
          minH={'60px'} 
          py={{ base: 2 }} 
          px={{ base: 4 }} 
          align={'center'} 
          justify={'space-between'}
          position="relative" // Added to control z-index context
        >
          <Flex flex={{ base: 1 }} justify={{ base: 'start', md: 'start' }} align="center">
            <Link 
              as={RouterLink} 
              to={'/'} 
              fontWeight={'bold'} 
              fontSize={'xl'} 
              color={brandColor}
              display="flex"
              alignItems="center"
            >
              <AppLogo />
            </Link>

            <Flex display={{ base: 'none', md: 'flex' }} ml={10}>
              <Stack direction={'row'} spacing={4} align={'center'}>
                {currentUser && (
                  <>
                    <Link as={RouterLink} to={'/trips'} color={textColor} fontWeight={500}>
                      My Trips
                    </Link>
                  </>
                )}
              </Stack>
            </Flex>
          </Flex>

          {currentUser ? (
            <HStack spacing={4} align="center">
              <DarkModeToggle />

              <Button
                as={RouterLink}
                to="/trips/new"
                size="sm"
                colorScheme="brand"
                leftIcon={<FaPlus />}
                display={{ base: 'none', md: 'inline-flex' }}
              >
                New Trip
              </Button>

              <Menu>
                <MenuButton
                  as={Button}
                  variant="ghost"
                  rightIcon={<ChevronDownIcon />}
                  _hover={{ bg: hoverBgColor }}
                >
                  <HStack>
                    <Avatar
                      size={'xs'}
                      name={currentUser.firstName + ' ' + currentUser.lastName}
                      bg={'brand.500'}
                    />
                    <Text display={{ base: 'none', md: 'block' }}>
                      {currentUser.firstName}
                    </Text>
                  </HStack>
                </MenuButton>
                <MenuList bg={backgroundColor} borderColor={borderColor}>
                  <MenuItem as={RouterLink} to="/profile">Profile</MenuItem>
                  <MenuDivider />
                  <MenuItem onClick={logout}>Sign Out</MenuItem>
                </MenuList>
              </Menu>

              <IconButton
                display={{ base: 'flex', md: 'none' }}
                onClick={onToggle}
                icon={isOpen ? <CloseIcon w={3} h={3} /> : <HamburgerIcon w={5} h={5} />}
                variant={'ghost'}
                aria-label={'Toggle Navigation'}
              />
            </HStack>
          ) : (
            <HStack spacing={4} align="center">
              <DarkModeToggle />
              <Button as={RouterLink} to="/login" variant={'ghost'} fontWeight={400}>
                Sign In
              </Button>
              <Button
                as={RouterLink}
                to="/register"
                display={{ base: 'none', md: 'inline-flex' }}
                colorScheme={'brand'}
              >
                Sign Up
              </Button>
            </HStack>
          )}
        </Flex>

        {/* Mobile menu */}
        <Collapse in={isOpen} animateOpacity>
          <Box
            pb={4}
            display={{ md: 'none' }}
            borderBottomWidth={1}
            borderColor={borderColor}
          >
            <Stack as={'nav'} spacing={4}>
              {currentUser ? (
                <>
                  <Link as={RouterLink} to={'/trips'} fontWeight={500}>
                    My Trips
                  </Link>
                  <Button
                    as={RouterLink}
                    to="/trips/new"
                    size="sm"
                    colorScheme="brand"
                    leftIcon={<FaPlus />}
                  >
                    New Trip
                  </Button>
                </>
              ) : (
                <Button
                  as={RouterLink}
                  to="/register"
                  colorScheme={'brand'}
                  w="full"
                >
                  Sign Up
                </Button>
              )}
            </Stack>
          </Box>
        </Collapse>
      </Container>
    </Box>
  );
};

export default Header;

// Source: components\sections\CTASection.tsx
// src/components/sections/CTASection.tsx
import React from 'react';
import { Link as RouterLink } from 'react-router-dom';
import {
  Box,
  Button,
  Container,
  Flex,
  Heading,
  Stack,
  Text,
  useColorModeValue,
} from '@chakra-ui/react';

const CTASection: React.FC = () => {
  const bgColor = useColorModeValue('brand.50', 'gray.800');
  const borderColor = useColorModeValue('brand.100', 'gray.700');

  return (
    <Box py={16} px={4}>
      <Container maxW="6xl">
        <Flex
          direction={{ base: 'column', md: 'row' }}
          align="center"
          justify="space-between"
          bg={bgColor}
          borderRadius="xl"
          overflow="hidden"
          boxShadow="lg"
          borderWidth="1px"
          borderColor={borderColor}
          position="relative"
        >
          {/* Background Image with Overlay */}
          <Box
            position="absolute"
            top={0}
            left={0}
            right={0}
            bottom={0}
            backgroundImage="url('/images/travel-background.jpg')"
            backgroundSize="cover"
            backgroundPosition="center"
            opacity={0.1}
            zIndex={0}
          />

          {/* Content */}
          <Stack
            spacing={6}
            p={{ base: 8, md: 10 }}
            maxW={{ base: "100%", md: "60%" }}
            zIndex={1}
          >
            <Heading as="h2" size="xl" color="brand.600">
              Start Preserving Your Travel Memories Today
            </Heading>
            <Text fontSize="lg">
              Sign up for free and begin documenting your adventures. Create beautiful travel journals, organize your photos, and share your experiences with friends and family.
            </Text>
            <Stack 
              direction={{ base: 'column', sm: 'row' }}
              spacing={4}
            >
              <Button
                as={RouterLink}
                to="/register"
                size="lg"
                colorScheme="brand"
                fontWeight="bold"
                px={8}
              >
                Sign Up Free
              </Button>
              <Button
                as={RouterLink}
                to="/login"
                size="lg"
                variant="outline"
                colorScheme="brand"
              >
                Sign In
              </Button>
            </Stack>
            <Text fontSize="sm" color="gray.500">
              No credit card required. Free account includes up to 100 photos and 10 trips.
            </Text>
          </Stack>

          {/* Image - Hidden on mobile */}
          <Box
            display={{ base: 'none', md: 'block' }}
            width={{ md: '40%' }}
            height={{ md: '400px' }}
            position="relative"
            overflow="hidden"
            zIndex={1}
          >
            <Box
              position="absolute"
              top={0}
              right={0}
              bottom={0}
              left={0}
              backgroundImage="url('/images/IMG_0806.JPG')"
              backgroundSize="cover"
              backgroundPosition="center"
              borderLeftWidth="1px"
              borderColor={borderColor}
            />
          </Box>
        </Flex>
      </Container>
    </Box>
  );
};

export default CTASection;

// Source: components\sections\FeaturesSection.tsx
// src/components/sections/FeaturesSection.tsx
import React from 'react';
import {
  Box,
  Container,
  Flex,
  Heading,
  SimpleGrid,
  Text,
  useColorModeValue,
  VStack,
} from '@chakra-ui/react';
import { FaMapMarkerAlt, FaImage, FaShareAlt } from 'react-icons/fa';

interface FeatureCardProps {
  title: string;
  description: string;
  icon: React.ReactNode;
}

const FeatureCard: React.FC<FeatureCardProps> = ({ title, description, icon }) => {
  const cardBg = useColorModeValue('white', 'gray.800');

  return (
    <VStack
      p={6}
      bg={cardBg}
      borderRadius="lg"
      boxShadow="md"
      spacing={4}
      align="center"
      textAlign="center"
      h="100%"
    >
      <Flex
        w="60px"
        h="60px"
        borderRadius="full"
        bg="brand.500"
        color="white"
        align="center"
        justify="center"
        fontSize="xl"
      >
        {icon}
      </Flex>
      <Heading as="h3" size="md">
        {title}
      </Heading>
      <Text color="gray.500">{description}</Text>
    </VStack>
  );
};

const FeaturesSection: React.FC = () => {
  const bgColor = useColorModeValue('gray.50', 'gray.900');
  
  return (
    <Box bg={bgColor} py={16}>
      <Container maxW="6xl">
        <VStack spacing={12}>
          <Heading as="h2" size="lg" textAlign="center">
            Features That Make Travel Documentation Easy
          </Heading>

          <SimpleGrid columns={{ base: 1, md: 3 }} spacing={10}>
            <FeatureCard
              title="Organize Your Photos"
              description="Upload and organize your travel photos in one place. Tag, sort, and filter them with ease for better memories management."
              icon={<FaImage />}
            />
            <FeatureCard
              title="Interactive Maps"
              description="Pin your locations on interactive maps to visualize your journey and remember where each memory was made."
              icon={<FaMapMarkerAlt />}
            />
            <FeatureCard
              title="Share Your Adventures"
              description="Generate shareable links to let friends and family experience your travels through your curated collection of memories."
              icon={<FaShareAlt />}
            />
          </SimpleGrid>
        </VStack>
      </Container>
    </Box>
  );
};

export default FeaturesSection;

// Source: components\sections\HeroSection.tsx
import React from 'react';
import { Link as RouterLink } from 'react-router-dom';
import {
    Box,
    Button,
    Container,
    Heading,
    Text,
    VStack,
    useColorModeValue,
} from '@chakra-ui/react';
import { FaPlus } from 'react-icons/fa';
import { useAuth } from '../../contexts/AuthContext';

const HeroSection: React.FC = () => {
    const { currentUser } = useAuth();
    const buttonColorScheme = useColorModeValue('whiteAlpha', 'whiteAlpha');

    return (
        <Box
            position="relative"
            height="100vh"
            overflow="hidden"
        >
            {/* Video Background */}
            <Box
                as="video"
                position="absolute"
                top="0"
                left="0"
                width="100%"
                height="100%"
                objectFit="cover"
                autoPlay
                loop
                muted
                src="/images/IMG_0177.MOV"
            />

            {/* Dark overlay for text readability */}
            <Box
                position="absolute"
                top="0"
                left="0"
                width="100%"
                height="100%"
                bg="rgba(0,0,0,0.5)"
            />

            <Container 
                maxW="container.xl" 
                position="relative" 
                zIndex={10} 
                height="100%" 
                display="flex" 
                alignItems="center"
            >
                <VStack 
                    spacing={6} 
                    align="center" 
                    color="white" 
                    textAlign="center"
                >
                    <Heading 
                        as="h1" 
                        size="2xl" 
                        fontWeight="bold"
                    >
                        Document Your Journey, Preserve Your Memories
                    </Heading>
                    <Text 
                        fontSize="xl" 
                        maxW="600px"
                    >
                        TravelMemories helps you organize, manage, and share your travel experiences in one place.
                    </Text>
                    {currentUser ? (
                        <Button
                            as={RouterLink}
                            to="/create-trip"
                            leftIcon={<FaPlus />}
                            colorScheme={buttonColorScheme}
                            size="lg"
                            mt={4}
                            _hover={{ bg: "white", color: "brand.500" }}
                        >
                            Create New Trip
                        </Button>
                    ) : (
                        <Button
                            as={RouterLink}
                            to="/register"
                            colorScheme={buttonColorScheme}
                            size="lg"
                            mt={4}
                        >
                            Get Started Free
                        </Button>
                    )}
                </VStack>
            </Container>
        </Box>
    );
};

export default HeroSection;

// Source: components\sections\RecentTripsSection.tsx
// src/components/sections/RecentTripsSection.tsx
import React from 'react';
import { Link as RouterLink } from 'react-router-dom';
import {
    Box,
    Button,
    Container,
    Flex,
    Heading,
    SimpleGrid,
    Stack,
    Text,
    useColorModeValue,
    VStack,
} from '@chakra-ui/react';
import { FaMapMarkerAlt, FaPlus, FaImage } from 'react-icons/fa';
import { Trip } from '../../types';
import LoadingSpinner from '../common/LoadingSpinner';
import ImagePlaceholder from '../common/ImagePlaceholder';

interface RecentTripsSectionProps {
    trips: Trip[];
    loading: boolean;
    error: string | null;
}

const RecentTripsSection: React.FC<RecentTripsSectionProps> = ({ trips, loading, error }) => {
    const cardBg = useColorModeValue('white', 'gray.800');
    const borderColor = useColorModeValue('gray.200', 'gray.700');

    const formatDate = (dateString: string): string => {
        const date = new Date(dateString);
        return date.toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'long',
            day: 'numeric'
        });
    };

    return (
        <Container maxW="6xl" py={12}>
            <Flex justify="space-between" align="center" mb={8}>
                <Heading as="h2" size="lg">
                    Recent Trips
                </Heading>
                <Button
                    as={RouterLink}
                    to="/trips"
                    variant="ghost"
                    colorScheme="brand"
                    size="sm"
                >
                    View All
                </Button>
            </Flex>

            {loading ? (
                <LoadingSpinner text="Loading your recent trips..." />
            ) : error ? (
                <Text color="red.500">{error}</Text>
            ) : trips.length === 0 ? (
                <VStack spacing={4} p={8} textAlign="center" bg="gray.50" borderRadius="lg">
                    <FaImage size={40} color="gray" />
                    <Heading as="h3" size="md">
                        No trips yet
                    </Heading>
                    <Text>Start by creating your first trip to document your adventures.</Text>
                    <Button
                        as={RouterLink}
                        to="/trips/new"
                        colorScheme="brand"
                        leftIcon={<FaPlus />}
                    >
                        Create New Trip
                    </Button>
                </VStack>
            ) : (
                <SimpleGrid columns={{ base: 1, sm: 2, md: 4 }} spacing={6}>
                    {trips.map((trip) => (
                        <Box
                            key={trip.id}
                            bg={cardBg}
                            borderRadius="lg"
                            overflow="hidden"
                            boxShadow="md"
                            borderWidth="1px"
                            borderColor={borderColor}
                            transition="transform 0.2s"
                            _hover={{ transform: 'translateY(-5px)' }}
                        >
                            <Box position="relative" height="180px">
                                <ImagePlaceholder
                                    text="Travel Memories"
                                    height="180px"
                                />
                            </Box>
                            <Stack p={4} spacing={2}>
                                <Heading as="h3" size="md" noOfLines={1}>
                                    {trip.name}
                                </Heading>
                                <Text fontSize="sm" color="gray.500">
                                    {formatDate(trip.startDate)} - {formatDate(trip.endDate)}
                                </Text>

                                {trip.locationName && (
                                    <Flex align="center" color="gray.500" fontSize="sm">
                                        <FaMapMarkerAlt />
                                        <Text ml={1} noOfLines={1}>{trip.locationName}</Text>
                                    </Flex>
                                )}

                                <Button
                                    as={RouterLink}
                                    to={`/trips/${trip.id}`}
                                    size="sm"
                                    colorScheme="brand"
                                    variant="outline"
                                    mt={2}
                                >
                                    View Details
                                </Button>
                            </Stack>
                        </Box>
                    ))}
                </SimpleGrid>
            )}
        </Container>
    );
};

export default RecentTripsSection;

// Source: components\trips\EnhancedImageUploader.tsx
import React, { useState, useCallback, useRef } from 'react';
import {
    Box,
    Button,
    Flex,
    Text,
    useToast,
    Progress,
    VStack,
    HStack,
    Icon,
    SimpleGrid,
    IconButton,
    Badge,
    Tooltip,
    useColorModeValue,
    CircularProgress,
    CircularProgressLabel,
} from '@chakra-ui/react';
import {
    FaUpload,
    FaTrash,
    FaCheck,
    FaExclamationTriangle,
    FaImage,
    FaInfoCircle
} from 'react-icons/fa';
import imageService from '../../services/imageService';
import { useDropzone } from 'react-dropzone';

interface EnhancedImageUploaderProps {
    tripId: string;
    onUploadComplete?: () => void;
    maxFiles?: number;
    maxSizeInMB?: number;
    allowedTypes?: string[];
}

interface PreviewFile extends File {
    id: string;
    preview: string;
    status: 'pending' | 'uploading' | 'success' | 'error';
    progress: number;
    errorMessage?: string;
}

const EnhancedImageUploader: React.FC<EnhancedImageUploaderProps> = ({
    tripId,
    onUploadComplete,
    maxFiles = 10,
    maxSizeInMB = 10,
    allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp']
}) => {
    const [files, setFiles] = useState<PreviewFile[]>([]);
    const [isUploading, setIsUploading] = useState(false);
    const [uploadProgress, setUploadProgress] = useState(0);
    const toast = useToast();
    const currentFileRef = useRef<number>(0);

    const bgColor = useColorModeValue('gray.50', 'gray.700');
    const borderColor = useColorModeValue('gray.200', 'gray.600');
    const activeBorderColor = useColorModeValue('brand.300', 'brand.400');
    const hoverBgColor = useColorModeValue('gray.100', 'gray.600');

    const formatFileSize = (size: number): string => {
        if (size < 1024) {
            return `${size} B`;
        } else if (size < 1024 * 1024) {
            return `${(size / 1024).toFixed(1)} KB`;
        } else {
            return `${(size / (1024 * 1024)).toFixed(1)} MB`;
        }
    };

    const validateFile = (file: File): { valid: boolean; error?: string } => {
        // Check file type
        if (!allowedTypes.includes(file.type)) {
            return {
                valid: false,
                error: `Unsupported file type "${file.type.split('/')[1]}". Only ${allowedTypes.map(t => t.split('/')[1]).join(', ')} are supported.`
            };
        }

        // Check file size
        if (file.size > maxSizeInMB * 1024 * 1024) {
            return {
                valid: false,
                error: `File too large (${formatFileSize(file.size)}). Maximum size is ${maxSizeInMB}MB.`
            };
        }

        return { valid: true };
    };

    const onDrop = useCallback((acceptedFiles: File[]) => {
        // Filter out files that would exceed the maxFiles limit
        const availableSlots = maxFiles - files.length;
        const filesToProcess = acceptedFiles.slice(0, availableSlots);

        if (filesToProcess.length === 0) return;

        // Process and validate files
        const filesWithPreview = filesToProcess.map(file => {
            const validation = validateFile(file);
            return Object.assign(file, {
                id: `${file.name}-${Date.now()}`,
                preview: URL.createObjectURL(file),
                status: validation.valid ? 'pending' as const : 'error' as const,
                progress: 0,
                errorMessage: validation.valid ? undefined : validation.error
            });
        });

        setFiles(current => [...current, ...filesWithPreview]);

        // Show a warning if some files were skipped
        if (acceptedFiles.length > availableSlots) {
            toast({
                title: 'Some files skipped',
                description: `Only ${availableSlots} more files can be added (maximum ${maxFiles} files).`,
                status: 'warning',
                duration: 5000,
                isClosable: true,
            });
        }
    }, [files.length, maxFiles, toast, allowedTypes, maxSizeInMB]);

    const { getRootProps, getInputProps, isDragActive } = useDropzone({
        onDrop,
        accept: Object.fromEntries(allowedTypes.map(type => [type, []])),
        disabled: isUploading || files.length >= maxFiles,
        maxSize: maxSizeInMB * 1024 * 1024
    });

    const removeFile = (id: string) => {
        setFiles(current => {
            const newFiles = current.filter(file => {
                if (file.id === id) {
                    // Revoke the object URL to avoid memory leaks
                    URL.revokeObjectURL(file.preview);
                    return false;
                }
                return true;
            });
            return newFiles;
        });
    };

    const handleUpload = async () => {
        const validFiles = files.filter(file => file.status === 'pending');
        if (validFiles.length === 0 || isUploading) return;

        setIsUploading(true);
        currentFileRef.current = 0;
        let successCount = 0;
        let totalCount = validFiles.length;

        try {
            // Check if token exists before attempting upload
            const token = localStorage.getItem('token');
            if (!token) {
                throw new Error('Authentication token not found. Please log in again.');
            }

            // Upload files one by one for better tracking and error handling
            for (let i = 0; i < validFiles.length; i++) {
                const file = validFiles[i];
                currentFileRef.current = i;

                // Update file status to uploading
                setFiles(current =>
                    current.map(f => f.id === file.id
                        ? { ...f, status: 'uploading' as const }
                        : f
                    )
                );

                try {
                    const tags = ['vacation', 'family', '2025']; // Default tags

                    // Upload the current file
                    await imageService.uploadImages([file], tripId, tags, (progress) => {
                        // Update progress for this file
                        setFiles(current =>
                            current.map(f => f.id === file.id
                                ? { ...f, progress }
                                : f
                            )
                        );

                        // Calculate overall progress
                        const totalProgress = validFiles.reduce((sum, _, index) => {
                            if (index < i) {
                                sum += 100; // If the file has already been uploaded, count as 100%
                            } else if (index === i) {
                                sum += progress; // Add the current file's progress
                            }
                            return sum;
                        }, 0);

                        setUploadProgress(Math.floor(totalProgress / totalCount));
                    });

                    // Mark this file as successfully uploaded
                    setFiles(current =>
                        current.map(f => f.id === file.id
                            ? { ...f, status: 'success' as const, progress: 100 }
                            : f
                        )
                    );

                    successCount++;
                } catch (error) {
                    console.error(`Error uploading file ${file.name}:`, error);

                    // Mark this file as failed
                    const errorMessage = error instanceof Error
                        ? error.message
                        : 'Failed to upload image';

                    setFiles(current =>
                        current.map(f => f.id === file.id
                            ? {
                                ...f,
                                status: 'error' as const,
                                errorMessage
                            }
                            : f
                        )
                    );
                }
            }

            // Show success toast
            if (successCount > 0) {
                toast({
                    title: 'Upload complete',
                    description: `Successfully uploaded ${successCount} ${successCount === 1 ? 'image' : 'images'}.`,
                    status: 'success',
                    duration: 5000,
                    isClosable: true,
                });

                // Call the completion callback
                if (onUploadComplete) {
                    onUploadComplete();
                }
            }

            // Show warning if some files failed
            if (successCount < totalCount) {
                toast({
                    title: 'Some uploads failed',
                    description: `${totalCount - successCount} ${totalCount - successCount === 1 ? 'image' : 'images'} failed to upload. Check the error messages for details.`,
                    status: 'warning',
                    duration: 5000,
                    isClosable: true,
                });
            }
        } catch (error) {
            console.error('Upload error:', error);
            toast({
                title: 'Upload error',
                description: error instanceof Error ? error.message : 'An unexpected error occurred during upload.',
                status: 'error',
                duration: 5000,
                isClosable: true,
            });
        } finally {
            setIsUploading(false);
            setUploadProgress(0);

            // Remove successfully uploaded files from the list after a short delay
            setTimeout(() => {
                setFiles(current => current.filter(file => file.status !== 'success'));
            }, 1500); // Show success state for 1.5 seconds before removing
        }
    };

    return (
        <Box width="100%">
            <VStack spacing={4} align="stretch">
                {/* Dropzone */}
                <Box
                    {...getRootProps()}
                    borderWidth={2}
                    borderRadius="md"
                    borderColor={isDragActive ? activeBorderColor : borderColor}
                    borderStyle="dashed"
                    p={6}
                    bg={isDragActive ? useColorModeValue('brand.50', 'rgba(79, 209, 197, 0.1)') : bgColor}
                    cursor={isUploading || files.length >= maxFiles ? 'not-allowed' : 'pointer'}
                    transition="all 0.2s"
                    _hover={{
                        borderColor: !(isUploading || files.length >= maxFiles) ? activeBorderColor : undefined,
                        bg: !(isUploading || files.length >= maxFiles) ? hoverBgColor : undefined,
                    }}
                >
                    <input {...getInputProps()} />
                    <VStack spacing={2}>
                        <Icon
                            as={FaImage}
                            boxSize={8}
                            color={isDragActive ? 'brand.500' : 'gray.400'}
                        />
                        <Text textAlign="center" fontWeight="medium">
                            {isDragActive
                                ? 'Drop the images here...'
                                : isUploading
                                    ? 'Upload in progress...'
                                    : files.length >= maxFiles
                                        ? `Maximum ${maxFiles} images reached`
                                        : 'Drag and drop images here, or click to select files'}
                        </Text>
                        <Text fontSize="sm" color="gray.500" textAlign="center">
                            Supported formats: JPEG, PNG, GIF, WebP (max {maxSizeInMB}MB each)
                        </Text>
                        <Text fontSize="sm" color="gray.500" textAlign="center">
                            {files.length} of {maxFiles} files selected
                        </Text>
                    </VStack>
                </Box>

                {/* Upload progress */}
                {isUploading && (
                    <Box>
                        <Flex justify="space-between" mb={1}>
                            <Text>Uploading: {uploadProgress}%</Text>
                            <Text>{currentFileRef.current + 1} of {files.filter(f => f.status === 'pending' || f.status === 'uploading').length}</Text>
                        </Flex>
                        <Progress value={uploadProgress} size="sm" colorScheme="brand" borderRadius="md" />
                    </Box>
                )}

                {/* File previews */}
                {files.length > 0 && (
                    <SimpleGrid columns={{ base: 2, sm: 3, md: 4 }} spacing={4}>
                        {files.map((file) => (
                            <Box
                                key={file.id}
                                position="relative"
                                borderWidth={1}
                                borderRadius="md"
                                overflow="hidden"
                                boxShadow="sm"
                                borderColor={
                                    file.status === 'success'
                                        ? 'green.300'
                                        : file.status === 'error'
                                            ? 'red.300'
                                            : borderColor
                                }
                            >
                                <Box position="relative" paddingBottom="100%" bg="gray.100">
                                    <Box
                                        as="img"
                                        src={file.preview}
                                        alt={file.name}
                                        position="absolute"
                                        top={0}
                                        left={0}
                                        width="100%"
                                        height="100%"
                                        objectFit="cover"
                                        opacity={file.status === 'uploading' ? 0.7 : 1}
                                    />

                                    {/* Status indicators */}
                                    {file.status === 'uploading' && (
                                        <Flex
                                            position="absolute"
                                            top={0}
                                            left={0}
                                            right={0}
                                            bottom={0}
                                            justify="center"
                                            align="center"
                                            bg="rgba(0, 0, 0, 0.3)"
                                        >
                                            <CircularProgress value={file.progress} color="brand.500" thickness="12px" size="50px">
                                                <CircularProgressLabel>{file.progress}%</CircularProgressLabel>
                                            </CircularProgress>
                                        </Flex>
                                    )}

                                    {file.status === 'success' && (
                                        <Flex
                                            position="absolute"
                                            top={0}
                                            left={0}
                                            right={0}
                                            bottom={0}
                                            bg="rgba(0, 0, 0, 0.3)"
                                            justify="center"
                                            align="center"
                                        >
                                            <Icon as={FaCheck} color="green.300" boxSize={8} />
                                        </Flex>
                                    )}

                                    {file.status === 'error' && (
                                        <Flex
                                            position="absolute"
                                            top={0}
                                            left={0}
                                            right={0}
                                            bottom={0}
                                            bg="rgba(0, 0, 0, 0.3)"
                                            justify="center"
                                            align="center"
                                        >
                                            <Tooltip label={file.errorMessage || 'Upload failed'} placement="top">
                                                <span>
                                                    <Icon as={FaExclamationTriangle} color="red.300" boxSize={8} />
                                                </span>
                                            </Tooltip>
                                        </Flex>
                                    )}
                                </Box>

                                <HStack justify="space-between" p={2} bg={useColorModeValue('white', 'gray.800')}>
                                    <VStack align="start" spacing={0} flex={1}>
                                        <Text fontSize="xs" noOfLines={1} fontWeight="medium">
                                            {file.name.length > 20
                                                ? `${file.name.substring(0, 10)}...${file.name.substring(file.name.length - 7)}`
                                                : file.name
                                            }
                                        </Text>
                                        <Text fontSize="xs" color="gray.500">
                                            {formatFileSize(file.size)}
                                        </Text>
                                    </VStack>

                                    {file.status !== 'uploading' && (
                                        <IconButton
                                            aria-label="Remove file"
                                            icon={<FaTrash />}
                                            size="xs"
                                            variant="ghost"
                                            colorScheme="red"
                                            onClick={() => removeFile(file.id)}
                                        />
                                    )}
                                </HStack>

                                {file.status === 'error' && file.errorMessage && (
                                    <Box
                                        p={2}
                                        bg="red.50"
                                        borderTop="1px solid"
                                        borderColor="red.200"
                                        _dark={{
                                            bg: "red.900",
                                            borderColor: "red.700"
                                        }}
                                    >
                                        <Text fontSize="xs" color="red.600" _dark={{ color: "red.200" }}>
                                            {file.errorMessage}
                                        </Text>
                                    </Box>
                                )}
                            </Box>
                        ))}
                    </SimpleGrid>
                )}

                {/* Upload button */}
                <Button
                    leftIcon={<FaUpload />}
                    colorScheme="brand"
                    onClick={handleUpload}
                    isLoading={isUploading}
                    loadingText="Uploading..."
                    isDisabled={files.filter(f => f.status === 'pending').length === 0}
                    size="lg"
                    width="100%"
                    mt={2}
                >
                    Upload {files.filter(f => f.status === 'pending').length > 0
                        ? `${files.filter(f => f.status === 'pending').length} ${files.filter(f => f.status === 'pending').length === 1 ? 'Image' : 'Images'
                        }`
                        : ''}
                </Button>
            </VStack>
        </Box>
    );
};

export default EnhancedImageUploader;

// Source: components\trips\ImageFilter.tsx
import React, { useState } from 'react';
import {
    Box,
    Input,
    InputGroup,
    InputLeftElement,
    Select,
    FormControl,
    FormLabel,
    Collapse,
    Button,
    useDisclosure,
    Flex,
    IconButton,
    Divider
} from '@chakra-ui/react';
import { FaSearch, FaChevronDown, FaChevronUp } from 'react-icons/fa';

interface ImageFilterProps {
    onFilterChange: (filters: ImageFilters) => void;
    hasAiImages: boolean;
}

export interface ImageFilters {
    searchTerm: string;
    sortBy: 'newest' | 'oldest' | 'name' | 'size';
    filterType: 'all' | 'ai' | 'regular';
}

const defaultFilters: ImageFilters = {
    searchTerm: '',
    sortBy: 'newest',
    filterType: 'all',
};

const ImageFilter: React.FC<ImageFilterProps> = ({ onFilterChange, hasAiImages }) => {
    const { isOpen, onToggle } = useDisclosure();
    const [filters, setFilters] = useState<ImageFilters>(defaultFilters);

    const handleFilterChange = (field: keyof ImageFilters, value: string) => {
        const newFilters = {
            ...filters,
            [field]: value,
        };
        setFilters(newFilters);
        onFilterChange(newFilters);
    };

    const resetFilters = () => {
        setFilters(defaultFilters);
        onFilterChange(defaultFilters);
    };

    return (
        <Box mb={6} borderWidth="1px" borderRadius="md" p={3}>
            <Flex justifyContent="space-between" alignItems="center">
                {/* Basic search always visible */}
                <InputGroup size="md" maxW={{ base: 'full', md: '300px' }}>
                    <InputLeftElement pointerEvents="none">
                        <FaSearch color="gray.300" />
                    </InputLeftElement>
                    <Input
                        placeholder="Search by filename"
                        value={filters.searchTerm}
                        onChange={(e) => handleFilterChange('searchTerm', e.target.value)}
                    />
                </InputGroup>

                <IconButton
                    aria-label={isOpen ? "Hide filters" : "Show filters"}
                    icon={isOpen ? <FaChevronUp /> : <FaChevronDown />}
                    variant="ghost"
                    onClick={onToggle}
                    size="sm"
                />
            </Flex>

            <Collapse in={isOpen} animateOpacity>
                <Box pt={4}>
                    <Divider mb={4} />
                    <Flex
                        direction={{ base: 'column', md: 'row' }}
                        gap={4}
                        alignItems={{ base: 'stretch', md: 'flex-end' }}
                    >
                        <FormControl>
                            <FormLabel fontSize="sm">Sort By</FormLabel>
                            <Select
                                value={filters.sortBy}
                                onChange={(e) => handleFilterChange('sortBy', e.target.value)}
                                size="md"
                            >
                                <option value="newest">Newest First</option>
                                <option value="oldest">Oldest First</option>
                                <option value="name">File Name</option>
                                <option value="size">File Size</option>
                            </Select>
                        </FormControl>

                        {hasAiImages && (
                            <FormControl>
                                <FormLabel fontSize="sm">Image Type</FormLabel>
                                <Select
                                    value={filters.filterType}
                                    onChange={(e) => handleFilterChange('filterType', e.target.value)}
                                    size="md"
                                >
                                    <option value="all">All Images</option>
                                    <option value="ai">AI Generated Only</option>
                                    <option value="regular">Regular Photos Only</option>
                                </Select>
                            </FormControl>
                        )}

                        <Button onClick={resetFilters} size="md" variant="outline" colorScheme="gray">
                            Reset Filters
                        </Button>
                    </Flex>
                </Box>
            </Collapse>
        </Box>
    );
};

export default ImageFilter;

// Source: components\trips\ImageGallery.tsx
import React, { useState, RefObject, useEffect } from 'react';
import {
    Box,
    SimpleGrid,
    IconButton,
    useDisclosure,
    Modal,
    ModalOverlay,
    ModalContent,
    ModalCloseButton,
    Flex,
    Text,
    Badge,
    useToast,
    AlertDialog,
    AlertDialogBody,
    AlertDialogFooter,
    AlertDialogHeader,
    AlertDialogContent,
    AlertDialogOverlay,
    Button,
    HStack,
    useColorModeValue,
    AspectRatio,
    Skeleton,
} from '@chakra-ui/react';
import { FaTrash, FaArrowLeft, FaArrowRight, FaRobot, FaCalendarAlt, FaThLarge, FaList } from 'react-icons/fa';
import { Image as ImageType } from '../../types';
import imageService from '../../services/imageService';
import { format } from 'date-fns';
import { getImageUrl } from '../../utils/imageUtils';

interface ImageGalleryProps {
    images: ImageType[];
    onDelete?: (imageId: string) => void;
    readonly?: boolean;
}

type ViewMode = 'grid' | 'list';

const ImageGallery: React.FC<ImageGalleryProps> = ({
    images,
    onDelete,
    readonly = false
}) => {
    const [currentImageIndex, setCurrentImageIndex] = useState<number | null>(null);
    const [imageToDelete, setImageToDelete] = useState<string | null>(null);
    const [viewMode, setViewMode] = useState<ViewMode>('grid');
    const [loadedImages, setLoadedImages] = useState<Record<string, boolean>>({});
    const { isOpen: isViewerOpen, onOpen: openViewer, onClose: closeViewer } = useDisclosure();
    const { isOpen: isDeleteOpen, onOpen: openDelete, onClose: closeDelete } = useDisclosure();
    const cancelRef = React.useRef<HTMLButtonElement>(null);
    const toast = useToast();

    const cardBg = useColorModeValue('white', 'gray.800');
    const cardBorderColor = useColorModeValue('gray.200', 'gray.700');
    const imageBgColor = useColorModeValue('gray.100', 'gray.700');
    const metaTextColor = useColorModeValue('gray.500', 'gray.400');

    // Track which images have loaded
    useEffect(() => {
        const newLoadedState: Record<string, boolean> = {};
        images.forEach(img => {
            newLoadedState[img.id] = loadedImages[img.id] || false;
        });
        setLoadedImages(newLoadedState);
    }, [images]);

    const handleImageLoad = (imageId: string) => {
        setLoadedImages(prev => ({
            ...prev,
            [imageId]: true
        }));
    };

    const handleImageClick = (index: number) => {
        setCurrentImageIndex(index);
        openViewer();
    };

    const navigateImages = (direction: 'prev' | 'next') => {
        if (currentImageIndex === null || images.length === 0) return;

        if (direction === 'prev') {
            setCurrentImageIndex(prevIndex =>
                prevIndex !== null ? (prevIndex === 0 ? images.length - 1 : prevIndex - 1) : 0
            );
        } else {
            setCurrentImageIndex(prevIndex =>
                prevIndex !== null ? (prevIndex === images.length - 1 ? 0 : prevIndex + 1) : 0
            );
        }
    };

    const confirmDelete = (imageId: string) => {
        setImageToDelete(imageId);
        openDelete();
    };

    const handleDelete = async () => {
        if (!imageToDelete) return;

        try {
            await imageService.deleteImage(imageToDelete);

            toast({
                title: 'Image deleted',
                description: 'The image has been deleted successfully.',
                status: 'success',
                duration: 3000,
                isClosable: true,
            });

            if (onDelete) {
                onDelete(imageToDelete);
            }
        } catch (error) {
            console.error('Error deleting image:', error);
            toast({
                title: 'Error',
                description: 'Failed to delete the image. Please try again.',
                status: 'error',
                duration: 5000,
                isClosable: true,
            });
        } finally {
            closeDelete();
            setImageToDelete(null);
        }
    };

    const currentImage = currentImageIndex !== null ? images[currentImageIndex] : null;

    const renderGridView = () => (
        <SimpleGrid columns={{ base: 2, sm: 3, md: 4, lg: 5 }} spacing={4}>
            {images.map((image, index) => (
                <Box
                    key={image.id}
                    position="relative"
                    borderRadius="md"
                    overflow="hidden"
                    boxShadow="md"
                    borderWidth="1px"
                    borderColor={cardBorderColor}
                    transition="transform 0.2s"
                    _hover={{ transform: 'scale(1.02)' }}
                    cursor="pointer"
                    onClick={() => handleImageClick(index)}
                    bg={cardBg}
                >
                    <AspectRatio ratio={1}>
                        <Box position="relative" bg={imageBgColor}>
                            {!loadedImages[image.id] && (
                                <Skeleton 
                                    position="absolute" 
                                    top="0" 
                                    left="0" 
                                    width="100%" 
                                    height="100%"
                                    startColor={useColorModeValue('gray.100', 'gray.700')}
                                    endColor={useColorModeValue('gray.300', 'gray.600')}
                                />
                            )}
                            <Box
                                as="img"
                                src={getImageUrl(image)}
                                alt={image.fileName}
                                width="100%"
                                height="100%"
                                objectFit="cover"
                                loading="lazy"
                                onLoad={() => handleImageLoad(image.id)}
                                style={{ opacity: loadedImages[image.id] ? 1 : 0 }}
                                transition="opacity 0.3s ease-in-out"
                            />

                            {image.isAiGenerated && (
                                <Badge
                                    position="absolute"
                                    top={2}
                                    left={2}
                                    colorScheme="purple"
                                    display="flex"
                                    alignItems="center"
                                    gap={1}
                                    zIndex={1}
                                >
                                    <FaRobot /> AI
                                </Badge>
                            )}

                            {!readonly && (
                                <IconButton
                                    aria-label="Delete image"
                                    icon={<FaTrash />}
                                    size="sm"
                                    colorScheme="red"
                                    position="absolute"
                                    top={2}
                                    right={2}
                                    opacity={0}
                                    _groupHover={{ opacity: 1 }}
                                    _hover={{ opacity: 1 }}
                                    zIndex={1}
                                    onClick={(e) => {
                                        e.stopPropagation();
                                        confirmDelete(image.id);
                                    }}
                                />
                            )}
                        </Box>
                    </AspectRatio>
                </Box>
            ))}
        </SimpleGrid>
    );

    const renderListView = () => (
        <Box>
            {images.map((image, index) => (
                <Flex
                    key={image.id}
                    mb={4}
                    borderWidth="1px"
                    borderRadius="md"
                    borderColor={cardBorderColor}
                    overflow="hidden"
                    boxShadow="sm"
                    bg={cardBg}
                    transition="transform 0.2s"
                    _hover={{ transform: 'translateX(5px)' }}
                    cursor="pointer"
                    onClick={() => handleImageClick(index)}
                >
                    <Box width="120px" height="90px" flexShrink={0} bg={imageBgColor} position="relative">
                        {!loadedImages[image.id] && (
                            <Skeleton 
                                position="absolute" 
                                top="0" 
                                left="0" 
                                width="100%" 
                                height="100%"
                            />
                        )}
                        <Box
                            as="img"
                            src={getImageUrl(image)}
                            alt={image.fileName}
                            width="100%"
                            height="100%"
                            objectFit="cover"
                            loading="lazy"
                            onLoad={() => handleImageLoad(image.id)}
                            style={{ opacity: loadedImages[image.id] ? 1 : 0 }}
                            transition="opacity 0.3s ease-in-out"
                        />
                    </Box>
                    <Flex flex="1" p={3} direction="column" justifyContent="center">
                        <Text fontWeight="medium" noOfLines={1}>
                            {image.fileName}
                        </Text>
                        <Flex fontSize="xs" color={metaTextColor} alignItems="center" mt={1}>
                            {image.takenAt && (
                                <Flex alignItems="center" mr={3}>
                                    <FaCalendarAlt size="0.8em" />
                                    <Text ml={1}>
                                        {format(new Date(image.takenAt), 'yyyy-MM-dd')}
                                    </Text>
                                </Flex>
                            )}
                            <Text>{Math.round(image.fileSize / 1024)} KB</Text>
                        </Flex>
                    </Flex>
                    <Flex p={2} alignItems="center">
                        {image.isAiGenerated && (
                            <Badge
                                colorScheme="purple"
                                display="flex"
                                alignItems="center"
                                gap={1}
                                mr={2}
                            >
                                <FaRobot /> AI
                            </Badge>
                        )}

                        {!readonly && (
                            <IconButton
                                aria-label="Delete image"
                                icon={<FaTrash />}
                                size="sm"
                                colorScheme="red"
                                variant="ghost"
                                onClick={(e) => {
                                    e.stopPropagation();
                                    confirmDelete(image.id);
                                }}
                            />
                        )}
                    </Flex>
                </Flex>
            ))}
        </Box>
    );

    return (
        <Box>
            {/* View toggle */}
            <Flex justifyContent="flex-end" mb={4}>
                <HStack spacing={2}>
                    <Text fontSize="sm" color={metaTextColor}>View:</Text>
                    <IconButton
                        aria-label="Grid view"
                        icon={<FaThLarge />}
                        size="sm"
                        colorScheme={viewMode === 'grid' ? 'brand' : 'gray'}
                        variant={viewMode === 'grid' ? 'solid' : 'ghost'}
                        onClick={() => setViewMode('grid')}
                    />
                    <IconButton
                        aria-label="List view"
                        icon={<FaList />}
                        size="sm"
                        colorScheme={viewMode === 'list' ? 'brand' : 'gray'}
                        variant={viewMode === 'list' ? 'solid' : 'ghost'}
                        onClick={() => setViewMode('list')}
                    />
                </HStack>
            </Flex>

            {/* Gallery content based on view mode */}
            {viewMode === 'grid' ? renderGridView() : renderListView()}

            {/* Full-size image viewer modal */}
            <Modal isOpen={isViewerOpen} onClose={closeViewer} size="full" isCentered>
                <ModalOverlay bg="blackAlpha.900" />
                <ModalContent bg="transparent" boxShadow="none" maxW="100vw" maxH="100vh">
                    <ModalCloseButton color="white" zIndex={2} />

                    <Flex
                        justify="center"
                        align="center"
                        height="100vh"
                        position="relative"
                        onClick={closeViewer}
                    >
                        {/* Navigation buttons */}
                        <IconButton
                            aria-label="Previous image"
                            icon={<FaArrowLeft />}
                            position="absolute"
                            left={4}
                            onClick={(e) => {
                                e.stopPropagation();
                                navigateImages('prev');
                            }}
                            colorScheme="whiteAlpha"
                            variant="ghost"
                            fontSize="2xl"
                            zIndex={1}
                        />

                        <IconButton
                            aria-label="Next image"
                            icon={<FaArrowRight />}
                            position="absolute"
                            right={4}
                            onClick={(e) => {
                                e.stopPropagation();
                                navigateImages('next');
                            }}
                            colorScheme="whiteAlpha"
                            variant="ghost"
                            fontSize="2xl"
                            zIndex={1}
                        />

                        {/* Current image */}
                        {currentImage && (
                            <Box
                                maxW="90vw"
                                maxH="90vh"
                                onClick={(e) => e.stopPropagation()}
                            >
                                <Box
                                    as="img"
                                    src={getImageUrl(currentImage)}
                                    alt={currentImage.fileName}
                                    maxH="80vh"
                                    maxW="90vw"
                                    objectFit="contain"
                                    borderRadius="md"
                                />
                                
                                {/* Image info */}
                                <Box
                                    bg="blackAlpha.700"
                                    p={3}
                                    borderRadius="md"
                                    mt={2}
                                    color="white"
                                >
                                    <Flex justify="space-between" align="center">
                                        <Text fontSize="md" fontWeight="medium">
                                            {currentImage.fileName}
                                        </Text>

                                        {currentImage.isAiGenerated && (
                                            <Badge colorScheme="purple" display="flex" alignItems="center" gap={1}>
                                                <FaRobot /> AI Generated
                                            </Badge>
                                        )}
                                    </Flex>

                                    {currentImage.takenAt && (
                                        <Flex align="center" gap={1} mt={1}>
                                            <FaCalendarAlt size="0.8em" />
                                            <Text fontSize="sm">
                                                Taken on {format(new Date(currentImage.takenAt), 'MMMM d, yyyy')}
                                            </Text>
                                        </Flex>
                                    )}

                                    {currentImage.isAiGenerated && currentImage.aiPrompt && (
                                        <Text fontSize="sm" mt={1}>
                                            <strong>Prompt:</strong> {currentImage.aiPrompt}
                                        </Text>
                                    )}
                                </Box>
                            </Box>
                        )}
                    </Flex>
                </ModalContent>
            </Modal>

            {/* Delete confirmation dialog */}
            <AlertDialog
                isOpen={isDeleteOpen}
                leastDestructiveRef={cancelRef as RefObject<any>}
                onClose={closeDelete}
            >
                <AlertDialogOverlay>
                    <AlertDialogContent bg={cardBg}>
                        <AlertDialogHeader fontSize="lg" fontWeight="bold">
                            Delete Image
                        </AlertDialogHeader>
                        <AlertDialogBody>
                            Are you sure you want to delete this image? This action cannot be undone.
                        </AlertDialogBody>
                        <AlertDialogFooter>
                            <Button ref={cancelRef} onClick={closeDelete}>
                                Cancel
                            </Button>
                            <Button colorScheme="red" onClick={handleDelete} ml={3}>
                                Delete
                            </Button>
                        </AlertDialogFooter>
                    </AlertDialogContent>
                </AlertDialogOverlay>
            </AlertDialog>
        </Box>
    );
};

export default ImageGallery;

// Source: components\trips\ImageUploader.tsx
import React, { useState, useCallback, useRef } from 'react';
import {
  Box,
  Button,
  Flex,
  Text,
  useToast,
  Progress,
  VStack,
  HStack,
  Icon,
  Image as ChakraImage,
  SimpleGrid,
  IconButton,
} from '@chakra-ui/react';
import { FaUpload, FaTrash, FaCheck, FaExclamationTriangle } from 'react-icons/fa';
import imageService from '../../services/imageService';
import { useDropzone } from 'react-dropzone';

interface ImageUploaderProps {
  tripId: string;
  onUploadComplete?: () => void;
  maxFiles?: number;
}

interface PreviewFile extends File {
  preview?: string;
  id?: string;
  status?: 'pending' | 'uploading' | 'success' | 'error';
  progress?: number;
}

const ImageUploader: React.FC<ImageUploaderProps> = ({
  tripId,
  onUploadComplete,
  maxFiles = 10
}) => {
  const [files, setFiles] = useState<PreviewFile[]>([]);
  const [isUploading, setIsUploading] = useState(false);
  const [uploadProgress, setUploadProgress] = useState(0);
  const toast = useToast();

  // Keep track of which file is currently being uploaded
  const currentFileRef = useRef<number>(0);

  const onDrop = useCallback((acceptedFiles: File[]) => {
    // Filter out files that would exceed the maxFiles limit
    const availableSlots = maxFiles - files.length;
    const newFiles = acceptedFiles.slice(0, availableSlots);

    // Create preview URLs for the files
    const filesWithPreview = newFiles.map(file =>
      Object.assign(file, {
        preview: URL.createObjectURL(file),
        status: 'pending' as const,
        progress: 0
      })
    );

    setFiles(current => [...current, ...filesWithPreview]);

    // Show a warning if some files were skipped
    if (acceptedFiles.length > availableSlots) {
      toast({
        title: 'Some files skipped',
        description: `Only ${availableSlots} more files can be added (maximum ${maxFiles} files).`,
        status: 'warning',
        duration: 5000,
        isClosable: true,
      });
    }
  }, [files.length, maxFiles, toast]);

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: {
      'image/*': ['.jpeg', '.jpg', '.png', '.gif', '.webp']
    },
    disabled: isUploading || files.length >= maxFiles
  });

  const removeFile = (index: number) => {
    setFiles(current => {
      const newFiles = [...current];
      // Revoke the object URL to avoid memory leaks
      if (newFiles[index].preview) {
        URL.revokeObjectURL(newFiles[index].preview!);
      }
      newFiles.splice(index, 1);
      return newFiles;
    });
  };

  const handleUpload = async () => {
    if (files.length === 0 || isUploading) return;

    setIsUploading(true);
    currentFileRef.current = 0;
    let successCount = 0;

    try {
      // Check if token exists before attempting upload
      const token = localStorage.getItem('token');
      if (!token) {
        throw new Error('Authentication token not found. Please log in again.');
      }

      // Upload files one by one for better tracking and error handling
      for (let i = 0; i < files.length; i++) {
        currentFileRef.current = i;

        // Update file status to uploading
        setFiles(current => {
          const newFiles = [...current];
          newFiles[i].status = 'uploading';
          return newFiles;
        });

        try {
          const tags = ['vacation', 'family', '2025'];  // מגדיר את התגים, ודא שאתה שולח את הערכים הנכונים

          // Upload the current file
          await imageService.uploadImages([files[i]], tripId, tags, (progress) => {
            // Update progress for this file
            setFiles(current => {
              const newFiles = [...current];
              newFiles[i].progress = progress;
              return newFiles;
            });

            // Calculate overall progress
            const totalProgress = files.reduce((sum, _, index) => {
              if (index < i) {
                sum += 100;  // אם הקובץ כבר הועלה, נחשב אותו כשלם
              } else if (index === i) {
                sum += progress;  // הוסף את ההתקדמות הנוכחית של הקובץ
              }
              return sum;
            }, 0);

            setUploadProgress(Math.floor(totalProgress / files.length));
          });

          // Mark this file as successfully uploaded
          setFiles(current => {
            const newFiles = [...current];
            newFiles[i].status = 'success';
            return newFiles;
          });

          successCount++;
        } catch (error) {
          console.error(`Error uploading file ${files[i].name}:`, error);
          // Mark this file as failed
          setFiles(current => {
            const newFiles = [...current];
            newFiles[i].status = 'error';
            return newFiles;
          });
        }
      }

      // Show success toast
      if (successCount > 0) {
        toast({
          title: 'Upload complete',
          description: `Successfully uploaded ${successCount} ${successCount === 1 ? 'image' : 'images'}.`,
          status: 'success',
          duration: 5000,
          isClosable: true,
        });

        // Call the completion callback
        if (onUploadComplete) {
          onUploadComplete();
        }
      }

      // Show warning if some files failed
      if (successCount < files.length) {
        toast({
          title: 'Some uploads failed',
          description: `${files.length - successCount} ${files.length - successCount === 1 ? 'image' : 'images'} failed to upload. You can try again.`,
          status: 'warning',
          duration: 5000,
          isClosable: true,
        });
      }
    } catch (error) {
      console.error('Upload error:', error);
      toast({
        title: 'Upload error',
        description: error instanceof Error ? error.message : 'An unexpected error occurred during upload.',
        status: 'error',
        duration: 5000,
        isClosable: true,
      });
    } finally {
      setIsUploading(false);
      setUploadProgress(0);

      // Remove successfully uploaded files from the list
      setFiles(current => current.filter(file => file.status !== 'success'));
    }
  };

  return (
    <Box width="100%">
      <VStack spacing={4} align="stretch">
        {/* Dropzone */}
        <Box
          {...getRootProps()}
          borderWidth={2}
          borderRadius="md"
          borderColor={isDragActive ? 'brand.500' : 'gray.200'}
          borderStyle="dashed"
          p={6}
          bg={isDragActive ? 'brand.50' : 'gray.50'}
          cursor={isUploading || files.length >= maxFiles ? 'not-allowed' : 'pointer'}
          transition="all 0.2s"
          _hover={{
            borderColor: !(isUploading || files.length >= maxFiles) ? 'brand.300' : undefined,
          }}
        >
          <input {...getInputProps()} />
          <VStack spacing={2}>
            <Icon as={FaUpload} boxSize={8} color="gray.400" />
            <Text textAlign="center">
              {isDragActive
                ? 'Drop the images here...'
                : isUploading
                  ? 'Upload in progress...'
                  : files.length >= maxFiles
                    ? `Maximum ${maxFiles} images reached`
                    : 'Drag and drop images here, or click to select files'}
            </Text>
            <Text fontSize="sm" color="gray.500" textAlign="center">
              Supported formats: JPEG, PNG, GIF, WebP
            </Text>
            <Text fontSize="sm" color="gray.500" textAlign="center">
              {files.length} of {maxFiles} files selected
            </Text>
          </VStack>
        </Box>

        {/* Upload progress */}
        {isUploading && (
          <Box>
            <Text mb={1}>Uploading: {uploadProgress}%</Text>
            <Progress value={uploadProgress} size="sm" colorScheme="brand" borderRadius="md" />
          </Box>
        )}

        {/* File previews */}
        {files.length > 0 && (
          <SimpleGrid columns={{ base: 2, sm: 3, md: 4 }} spacing={4}>
            {files.map((file, index) => (
              <Box
                key={index}
                position="relative"
                borderWidth={1}
                borderRadius="md"
                overflow="hidden"
              >
                <Box position="relative" paddingBottom="100%" bg="gray.100">
                  <ChakraImage
                    src={file.preview}
                    alt={file.name}
                    position="absolute"
                    top={0}
                    left={0}
                    width="100%"
                    height="100%"
                    objectFit="cover"
                    opacity={file.status === 'uploading' ? 0.7 : 1}
                  />

                  {/* Status indicators */}
                  {file.status === 'uploading' && (
                    <Box position="absolute" bottom={0} left={0} right={0} bg="rgba(0,0,0,0.5)" p={1}>
                      <Progress size="xs" value={file.progress} colorScheme="brand" />
                    </Box>
                  )}

                  {file.status === 'success' && (
                    <Flex
                      position="absolute"
                      top={0}
                      left={0}
                      right={0}
                      bottom={0}
                      bg="rgba(0,0,0,0.3)"
                      justify="center"
                      align="center"
                    >
                      <Icon as={FaCheck} color="white" boxSize={8} />
                    </Flex>
                  )}

                  {file.status === 'error' && (
                    <Flex
                      position="absolute"
                      top={0}
                      left={0}
                      right={0}
                      bottom={0}
                      bg="rgba(0,0,0,0.3)"
                      justify="center"
                      align="center"
                    >
                      <Icon as={FaExclamationTriangle} color="red.300" boxSize={8} />
                    </Flex>
                  )}
                </Box>

                <HStack justify="space-between" p={2} bg="white">
                  <Text fontSize="xs" noOfLines={1} maxW="70%">
                    {file.name.length > 20
                      ? `${file.name.substring(0, 10)}...${file.name.substring(file.name.length - 7)}`
                      : file.name
                    }
                  </Text>

                  {file.status !== 'uploading' && (
                    <IconButton
                      aria-label="Remove file"
                      icon={<FaTrash />}
                      size="xs"
                      variant="ghost"
                      colorScheme="red"
                      onClick={(e) => {
                        e.stopPropagation();
                        removeFile(index);
                      }}
                    />
                  )}
                </HStack>
              </Box>
            ))}
          </SimpleGrid>
        )}

        {/* Upload button */}
        <Button
          leftIcon={<FaUpload />}
          colorScheme="brand"
          onClick={handleUpload}
          isLoading={isUploading}
          loadingText="Uploading..."
          isDisabled={files.length === 0 || files.every(f => f.status === 'error')}
          size="lg"
          width="100%"
        >
          Upload {files.length > 0 ? `${files.length} ${files.length === 1 ? 'Image' : 'Images'}` : ''}
        </Button>
      </VStack>
    </Box>
  );
};

export default ImageUploader;

// Source: components\trips\ImageViewer.tsx
import React from 'react';
import {
    Modal,
    ModalOverlay,
    ModalContent,
    ModalCloseButton,
    Flex,
    Box,
    Text,
    Badge,
    IconButton,
} from '@chakra-ui/react';
import { FaArrowLeft, FaArrowRight, FaRobot, FaCalendarAlt } from 'react-icons/fa';
import { Image as ImageType } from '../../types';
import { format } from 'date-fns';
import { getImageUrl } from '../../utils/imageUtils';

interface ImageViewerProps {
    isOpen: boolean;
    onClose: () => void;
    images: ImageType[];
    currentIndex: number | null;
    onIndexChange: (index: number) => void;
}

const ImageViewer: React.FC<ImageViewerProps> = ({
    isOpen,
    onClose,
    images,
    currentIndex,
    onIndexChange
}) => {
    if (!isOpen || currentIndex === null || images.length === 0) {
        return null;
    }

    const currentImage = images[currentIndex];

    const navigateImages = (direction: 'prev' | 'next') => {
        if (direction === 'prev') {
            onIndexChange(currentIndex === 0 ? images.length - 1 : currentIndex - 1);
        } else {
            onIndexChange(currentIndex === images.length - 1 ? 0 : currentIndex + 1);
        }
    };

    return (
        <Modal isOpen={isOpen} onClose={onClose} size="full" isCentered>
            <ModalOverlay bg="blackAlpha.900" />
            <ModalContent bg="transparent" boxShadow="none" maxW="100vw" maxH="100vh">
                <ModalCloseButton color="white" zIndex={2} />

                <Flex
                    justify="center"
                    align="center"
                    height="100vh"
                    position="relative"
                    onClick={onClose}
                >
                    {/* Navigation buttons */}
                    <IconButton
                        aria-label="Previous image"
                        icon={<FaArrowLeft />}
                        position="absolute"
                        left={4}
                        onClick={(e) => {
                            e.stopPropagation();
                            navigateImages('prev');
                        }}
                        colorScheme="whiteAlpha"
                        variant="ghost"
                        fontSize="2xl"
                        zIndex={1}
                    />

                    <IconButton
                        aria-label="Next image"
                        icon={<FaArrowRight />}
                        position="absolute"
                        right={4}
                        onClick={(e) => {
                            e.stopPropagation();
                            navigateImages('next');
                        }}
                        colorScheme="whiteAlpha"
                        variant="ghost"
                        fontSize="2xl"
                        zIndex={1}
                    />

                    {/* Current image */}
                    <Box
                        maxW="90vw"
                        maxH="90vh"
                        onClick={(e) => e.stopPropagation()}
                    >
                        <Box
                            as="img"
                            src={getImageUrl(currentImage)}
                            alt={currentImage.fileName}
                            maxH="80vh"
                            maxW="90vw"
                            objectFit="contain"
                            borderRadius="md"
                        />

                        {/* Image info */}
                        <Box
                            bg="blackAlpha.700"
                            p={3}
                            borderRadius="md"
                            mt={2}
                            color="white"
                        >
                            <Flex justify="space-between" align="center">
                                <Text fontSize="md" fontWeight="medium">
                                    {currentImage.fileName}
                                </Text>

                                {currentImage.isAiGenerated && (
                                    <Badge colorScheme="purple" display="flex" alignItems="center" gap={1}>
                                        <FaRobot /> AI Generated
                                    </Badge>
                                )}
                            </Flex>

                            {currentImage.takenAt && (
                                <Flex align="center" gap={1} mt={1}>
                                    <FaCalendarAlt size="0.8em" />
                                    <Text fontSize="sm">
                                        Taken on {format(new Date(currentImage.takenAt), 'MMMM d, yyyy')}
                                    </Text>
                                </Flex>
                            )}

                            {currentImage.isAiGenerated && currentImage.aiPrompt && (
                                <Text fontSize="sm" mt={1}>
                                    <strong>Prompt:</strong> {currentImage.aiPrompt}
                                </Text>
                            )}
                        </Box>
                    </Box>
                </Flex>
            </ModalContent>
        </Modal>
    );
};

export default ImageViewer;

// Source: components\trips\MapLocationPicker.tsx
import React, { useEffect, useState } from 'react';
import { Box, Button, Input, InputGroup, InputRightElement, VStack } from '@chakra-ui/react';
import L from 'leaflet';
import { MapContainer, TileLayer, Marker, useMap } from 'react-leaflet';
import 'leaflet/dist/leaflet.css';

// Fix Leaflet icon issues
delete (L.Icon.Default.prototype as any)._getIconUrl;
L.Icon.Default.mergeOptions({
    iconRetinaUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon-2x.png',
    iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon.png',
    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png',
});

interface MapLocationPickerProps {
    onLocationSelect: (locationName: string, latitude: number, longitude: number) => void;
    initialLatitude?: number;
    initialLongitude?: number;
}

// Map controller component for events and updates
const MapController: React.FC<{
    setMarkerPosition: (lat: number, lng: number) => void;
    fetchLocationName: (lat: number, lng: number) => void;
}> = ({ setMarkerPosition, fetchLocationName }) => {
    const map = useMap();

    useEffect(() => {
        map.on('click', (e: L.LeafletMouseEvent) => {
            const { lat, lng } = e.latlng;
            setMarkerPosition(lat, lng);
            fetchLocationName(lat, lng);
        });

        return () => {
            map.off('click');
        };
    }, [map, setMarkerPosition, fetchLocationName]);

    return null;
};

const MapLocationPicker: React.FC<MapLocationPickerProps> = ({
    onLocationSelect,
    initialLatitude,
    initialLongitude
}) => {
    const [searchQuery, setSearchQuery] = useState('');
    const [markerPosition, setMarkerPosition] = useState<[number, number] | null>(
        initialLatitude && initialLongitude ? [initialLatitude, initialLongitude] : null
    );
    const [selectedLocation, setSelectedLocation] = useState({
        lat: initialLatitude || 0,
        lng: initialLongitude || 0,
        name: ''
    });

    const fetchLocationName = async (lat: number, lng: number) => {
        try {
            // Using Nominatim for reverse geocoding (free OpenStreetMap service)
            const response = await fetch(
                `https://nominatim.openstreetmap.org/reverse?format=json&lat=${lat}&lon=${lng}&zoom=18&addressdetails=1`
            );
            const data = await response.json();

            let locationName = 'Unknown location';
            if (data && data.display_name) {
                locationName = data.display_name;
            }

            setSelectedLocation({
                lat,
                lng,
                name: locationName
            });
        } catch (error) {
            console.error('Error fetching location name:', error);
            setSelectedLocation({
                lat,
                lng,
                name: `Location at ${lat.toFixed(6)}, ${lng.toFixed(6)}`
            });
        }
    };

    const handleSearch = async () => {
        if (!searchQuery.trim()) return;

        try {
            // Using Nominatim for geocoding (free OpenStreetMap service)
            const response = await fetch(
                `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(searchQuery)}`
            );
            const data = await response.json();

            if (data && data.length > 0) {
                const result = data[0];
                const lat = parseFloat(result.lat);
                const lng = parseFloat(result.lon);

                setMarkerPosition([lat, lng]);
                setSelectedLocation({
                    lat,
                    lng,
                    name: result.display_name
                });
            }
        } catch (error) {
            console.error('Error searching location:', error);
        }
    };

    const handleConfirmLocation = () => {
        if (selectedLocation.lat && selectedLocation.lng) {
            onLocationSelect(
                selectedLocation.name,
                selectedLocation.lat,
                selectedLocation.lng
            );
        }
    };

    // Default to Jerusalem if no initial coordinates
    const defaultPosition: [number, number] = [
        initialLatitude || 31.7683,
        initialLongitude || 35.2137
    ];

    return (
        <Box position="relative" height="100%" width="100%">
            {/* Map container */}
            <Box height="100%" width="100%" id="map-container">
                <MapContainer
                    center={markerPosition || defaultPosition}
                    zoom={markerPosition ? 13 : 8}
                    style={{ height: '100%', width: '100%' }}
                >
                    <TileLayer
                        attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                        url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
                    />
                    {markerPosition && <Marker position={markerPosition} />}
                    <MapController
                        setMarkerPosition={(lat, lng) => setMarkerPosition([lat, lng])}
                        fetchLocationName={fetchLocationName}
                    />
                </MapContainer>
            </Box>

            {/* Search and controls overlay */}
            <VStack
                position="absolute"
                top={2}
                left={2}
                right={2}
                zIndex={1000}
                spacing={2}
                align="stretch"
                backgroundColor="rgba(255, 255, 255, 0.8)"
                p={2}
                borderRadius="md"
            >
                <InputGroup size="md">
                    <Input
                        placeholder="Search for a location"
                        value={searchQuery}
                        onChange={(e) => setSearchQuery(e.target.value)}
                        onKeyPress={(e) => e.key === 'Enter' && handleSearch()}
                        backgroundColor="white"
                    />
                    <InputRightElement width="4.5rem">
                        <Button h="1.75rem" size="sm" onClick={handleSearch}>
                            Search
                        </Button>
                    </InputRightElement>
                </InputGroup>

                <Button
                    colorScheme="brand"
                    onClick={handleConfirmLocation}
                    isDisabled={!selectedLocation.lat || !selectedLocation.lng}
                >
                    Confirm Location
                </Button>
            </VStack>
        </Box>
    );
};

export default MapLocationPicker;

// Source: components\trips\TripForm.tsx
import React, { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import {
    Box,
    Button,
    FormControl,
    FormLabel,
    Input,
    FormErrorMessage,
    VStack,
    Heading,
    Textarea,
    Flex,
    useToast,
    Text,
    HStack,
    IconButton,
} from '@chakra-ui/react';
import { Trip } from '../../types';
import tripService from '../../services/tripService';
import DatePicker from 'react-datepicker';
import 'react-datepicker/dist/react-datepicker.css';
import { FaMapMarkerAlt } from 'react-icons/fa';
import MapLocationPicker from './MapLocationPicker';

interface TripFormProps {
    initialData?: Partial<Trip>;
    isEditing?: boolean;
}

interface FormErrors {
    [key: string]: string;
}

const TripForm: React.FC<TripFormProps> = ({ initialData, isEditing = false }) => {
    const [formData, setFormData] = useState({
        name: initialData?.name || '',
        description: initialData?.description || '',
        startDate: initialData?.startDate ? new Date(initialData.startDate) : new Date(),
        endDate: initialData?.endDate ? new Date(initialData.endDate) : new Date(),
        locationName: initialData?.locationName || '',
        latitude: initialData?.latitude || undefined,
        longitude: initialData?.longitude || undefined,
    });

    const [errors, setErrors] = useState<FormErrors>({});
    const [loading, setLoading] = useState(false);
    const [showMap, setShowMap] = useState(false);

    const navigate = useNavigate();
    const toast = useToast();

    const handleChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
        const { name, value } = e.target;
        setFormData({ ...formData, [name]: value });

        // Clear errors when user starts typing
        if (errors[name]) {
            setErrors({ ...errors, [name]: '' });
        }
    };

    const handleStartDateChange = (date: Date | null) => {
        if (date) {
            setFormData({ ...formData, startDate: date });
            if (errors.startDate) {
                setErrors({ ...errors, startDate: '' });
            }

            // If the end date is before the start date, update it
            if (formData.endDate < date) {
                setFormData(prev => ({ ...prev, endDate: date }));
            }
        }
    };

    const handleEndDateChange = (date: Date | null) => {
        if (date) {
            setFormData({ ...formData, endDate: date });
            if (errors.endDate) {
                setErrors({ ...errors, endDate: '' });
            }
        }
    };

    const handleLocationSelect = (locationName: string, lat: number, lng: number) => {
        setFormData({
            ...formData,
            locationName,
            latitude: lat,
            longitude: lng
        });
        setShowMap(false);

        if (errors.locationName) {
            setErrors({ ...errors, locationName: '' });
        }
    };

    const validateForm = (): boolean => {
        const newErrors: FormErrors = {};
        if (!formData.name.trim()) {
            newErrors.name = 'Trip name is required';
        }

        if (!formData.startDate) {
            newErrors.startDate = 'Start date is required';
        }

        if (!formData.endDate) {
            newErrors.endDate = 'End date is required';
        }

        if (formData.startDate && formData.endDate && formData.startDate > formData.endDate) {
            newErrors.endDate = 'End date cannot be before start date';
        }

        setErrors(newErrors);
        return Object.keys(newErrors).length === 0;
    };

    const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
        e.preventDefault();
        if (!validateForm()) return;

        setLoading(true);

        try {
            const tripData = {
                name: formData.name,
                description: formData.description,
                startDate: formData.startDate.toISOString(),
                endDate: formData.endDate.toISOString(),
                locationName: formData.locationName,
                latitude: formData.latitude,
                longitude: formData.longitude,
            };

            if (isEditing && initialData?.id) {
                await tripService.updateTrip(initialData.id, tripData);
                toast({
                    title: 'Trip updated',
                    description: `${formData.name} has been updated successfully.`,
                    status: 'success',
                    duration: 5000,
                    isClosable: true,
                });
                navigate(`/trips/${initialData.id}`);
            } else {
                const newTrip = await tripService.createTrip(tripData);
                toast({
                    title: 'Trip created',
                    description: `${formData.name} has been created successfully.`,
                    status: 'success',
                    duration: 5000,
                    isClosable: true,
                });
                navigate(`/trips/${newTrip.id}`);
            }
        } catch (error) {
            console.error('Error saving trip:', error);
            toast({
                title: 'Error',
                description: 'There was an error saving your trip. Please try again.',
                status: 'error',
                duration: 5000,
                isClosable: true,
            });
        } finally {
            setLoading(false);
        }
    };

    return (
        <Box maxW="800px" mx="auto" py={8} px={4}>
            <Heading as="h1" size="xl" mb={6}>
                {isEditing ? 'Edit Trip' : 'Create New Trip'}
            </Heading>

            <form onSubmit={handleSubmit}>
                <VStack spacing={6} align="start">
                    <FormControl isInvalid={!!errors.name} isRequired>
                        <FormLabel htmlFor="name">Trip Name</FormLabel>
                        <Input
                            id="name"
                            name="name"
                            value={formData.name}
                            onChange={handleChange}
                            placeholder="Enter a name for your trip"
                        />
                        <FormErrorMessage>{errors.name}</FormErrorMessage>
                    </FormControl>

                    <FormControl>
                        <FormLabel htmlFor="description">Description</FormLabel>
                        <Textarea
                            id="description"
                            name="description"
                            value={formData.description || ''}
                            onChange={handleChange}
                            placeholder="Describe your trip (optional)"
                            rows={4}
                        />
                    </FormControl>

                    <Flex width="100%" gap={4} direction={{ base: 'column', md: 'row' }}>
                        <FormControl isInvalid={!!errors.startDate} isRequired flex="1">
                            <FormLabel htmlFor="startDate">Start Date</FormLabel>
                            <Box border="1px solid" borderColor="gray.200" borderRadius="md">
                                <DatePicker
                                    selected={formData.startDate}
                                    onChange={handleStartDateChange}
                                    selectsStart
                                    startDate={formData.startDate}
                                    endDate={formData.endDate}
                                    dateFormat="MMMM d, yyyy"
                                    className="chakra-input"
                                    wrapperClassName="date-picker-wrapper"
                                />
                            </Box>
                            <FormErrorMessage>{errors.startDate}</FormErrorMessage>
                        </FormControl>

                        <FormControl isInvalid={!!errors.endDate} isRequired flex="1">
                            <FormLabel htmlFor="endDate">End Date</FormLabel>
                            <Box border="1px solid" borderColor="gray.200" borderRadius="md">
                                <DatePicker
                                    selected={formData.endDate}
                                    onChange={handleEndDateChange}
                                    selectsEnd
                                    startDate={formData.startDate}
                                    endDate={formData.endDate}
                                    minDate={formData.startDate}
                                    dateFormat="MMMM d, yyyy"
                                    className="chakra-input"
                                    wrapperClassName="date-picker-wrapper"
                                />
                            </Box>
                            <FormErrorMessage>{errors.endDate}</FormErrorMessage>
                        </FormControl>
                    </Flex>

                    <FormControl isInvalid={!!errors.locationName}>
                        <FormLabel htmlFor="locationName">Location</FormLabel>
                        <HStack>
                            <Input
                                id="locationName"
                                name="locationName"
                                value={formData.locationName || ''}
                                onChange={handleChange}
                                placeholder="Enter location name (optional)"
                                readOnly={!!formData.latitude && !!formData.longitude}
                            />
                            <IconButton
                                aria-label="Pick location on map"
                                icon={<FaMapMarkerAlt />}
                                onClick={() => setShowMap(!showMap)}
                                colorScheme="brand"
                            />
                        </HStack>
                        {formData.latitude && formData.longitude && (
                            <Text fontSize="sm" color="gray.500" mt={1}>
                                Coordinates: {formData.latitude.toFixed(6)}, {formData.longitude.toFixed(6)}
                            </Text>
                        )}
                        <FormErrorMessage>{errors.locationName}</FormErrorMessage>
                    </FormControl>

                    {showMap && (
                        <Box width="100%" height="400px" borderRadius="md" overflow="hidden">
                            <MapLocationPicker
                                onLocationSelect={handleLocationSelect}
                                initialLatitude={formData.latitude}
                                initialLongitude={formData.longitude}
                            />
                        </Box>
                    )}

                    <Flex width="100%" justify="space-between" mt={4}>
                        <Button
                            variant="outline"
                            onClick={() => navigate(-1)}
                        >
                            Cancel
                        </Button>
                        <Button
                            type="submit"
                            colorScheme="brand"
                            isLoading={loading}
                            loadingText={isEditing ? "Updating" : "Creating"}
                        >
                            {isEditing ? 'Update Trip' : 'Create Trip'}
                        </Button>
                    </Flex>
                </VStack>
            </form>
        </Box>
    );
};

export default TripForm;

// Source: components\trips\TripMap.tsx
import React from 'react';
import { Box } from '@chakra-ui/react';
import L from 'leaflet';
import { MapContainer, TileLayer, Marker, Popup } from 'react-leaflet';
import 'leaflet/dist/leaflet.css';

delete (L.Icon.Default.prototype as any)._getIconUrl;
L.Icon.Default.mergeOptions({
  iconRetinaUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon-2x.png',
  iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon.png',
  shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png',
});

interface TripMapProps {
  latitude: number;
  longitude: number;
  locationName?: string;
}

const TripMap: React.FC<TripMapProps> = ({ latitude, longitude, locationName }) => {
  const position: [number, number] = [latitude, longitude];
  
  return (
    <Box 
      height="100%" 
      width="100%" 
      borderRadius="md"
      overflow="hidden"
    >
      <MapContainer 
        center={position} 
        zoom={13} 
        style={{ height: '100%', width: '100%' }}
      >
        <TileLayer
          attribution='&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
          url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
        />
        <Marker position={position}>
          {locationName && <Popup>{locationName}</Popup>}
        </Marker>
      </MapContainer>
    </Box>
  );
};

export default TripMap;

// Source: pages\auth\LoginPage.tsx
import React from 'react';
import LoginForm from '../../components/auth/LoginForm';

const LoginPage: React.FC = () => {
  return <LoginForm />;
};

export default LoginPage;

// Source: pages\auth\RegisterPage.tsx
import React from 'react';
import RegisterForm from '../../components/auth/RegisterForm';

const RegisterPage: React.FC = () => {
  return <RegisterForm />;
};

export default RegisterPage;

// Source: pages\trips\SharedTripPage.tsx
import React, { useEffect, useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import {
    Box,
    Button,
    Container,
    Flex,
    Heading,
    Text,
    Tabs,
    TabList,
    TabPanels,
    Tab,
    TabPanel,
    HStack,
    Icon,
    Spinner,
    Divider,
    useColorModeValue,
} from '@chakra-ui/react';
import { FaCalendarAlt, FaMapMarkerAlt, FaImages, FaArrowLeft } from 'react-icons/fa';
import tripService from '../../services/tripService';
import imageService from '../../services/imageService';
import { Trip, Image } from '../../types';
import ImageGallery from '../../components/trips/ImageGallery';
import TripMap from '../../components/trips/TripMap';
import { format } from 'date-fns';

const SharedTripPage: React.FC = () => {
    const { shareId } = useParams<{ shareId: string }>();
    const [trip, setTrip] = useState<Trip | null>(null);
    const [images, setImages] = useState<Image[]>([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const navigate = useNavigate();

    const bgColor = useColorModeValue('white', 'gray.800');

    useEffect(() => {
        const fetchSharedTrip = async () => {
            if (!shareId) return;

            setLoading(true);
            setError(null);

            try {
                const tripData = await tripService.getSharedTrip(shareId);
                setTrip(tripData);

                const imagesData = await imageService.getImages(tripData.id);
                setImages(imagesData);
            } catch (error) {
                console.error('Error fetching shared trip:', error);
                setError("The trip you're looking for doesn't exist or is no longer shared.");
            } finally {
                setLoading(false);
            }
        };

        fetchSharedTrip();
    }, [shareId]);

    if (loading) {
        return (
            <Flex justify="center" align="center" minH="50vh">
                <Spinner size="xl" color="brand.500" />
            </Flex>
        );
    }

    if (error || !trip) {
        return (
            <Container maxW="container.xl" py={8}>
                <Box
                    bg={bgColor}
                    p={8}
                    borderRadius="lg"
                    boxShadow="lg"
                    textAlign="center"
                >
                    <Heading as="h1" size="xl" mb={4}>Trip Not Found</Heading>
                    <Text mb={6}>{error || "The trip you're looking for doesn't exist or is no longer shared."}</Text>
                    <Button
                        leftIcon={<FaArrowLeft />}
                        colorScheme="brand"
                        onClick={() => navigate('/')}
                    >
                        Back to Home
                    </Button>
                </Box>
            </Container>
        );
    }

    return (
        <Container maxW="container.xl" py={8}>
            <Box
                bg={bgColor}
                p={6}
                borderRadius="lg"
                boxShadow="md"
                mb={6}
            >
                <Heading as="h1" size="xl">{trip.name}</Heading>
                <HStack mt={2} spacing={4}>
                    <HStack>
                        <Icon as={FaCalendarAlt} color="gray.500" />
                        <Text color="gray.600">
                            {format(new Date(trip.startDate), 'MMM d, yyyy')} - {format(new Date(trip.endDate), 'MMM d, yyyy')}
                        </Text>
                    </HStack>
                    {trip.locationName && (
                        <HStack>
                            <Icon as={FaMapMarkerAlt} color="gray.500" />
                            <Text color="gray.600">{trip.locationName}</Text>
                        </HStack>
                    )}
                </HStack>

                {trip.description && (
                    <>
                        <Divider my={4} />
                        <Text>{trip.description}</Text>
                    </>
                )}
            </Box>

            {/* Tabs for different trip content */}
            <Tabs colorScheme="brand" isLazy>
                <TabList>
                    <Tab><HStack><Icon as={FaImages} /><Text>Photos</Text></HStack></Tab>
                    {(trip.latitude && trip.longitude) && (
                        <Tab><HStack><Icon as={FaMapMarkerAlt} /><Text>Map</Text></HStack></Tab>
                    )}
                </TabList>

                <TabPanels>
                    {/* Photos tab */}
                    <TabPanel px={0}>
                        {images.length === 0 ? (
                            <Box
                                borderWidth={2}
                                borderRadius="md"
                                borderColor="gray.200"
                                borderStyle="dashed"
                                p={12}
                                textAlign="center"
                            >
                                <Icon as={FaImages} boxSize={12} color="gray.300" mb={4} />
                                <Heading as="h3" size="md" mb={2}>No Photos</Heading>
                                <Text>This trip doesn't have any photos yet.</Text>
                            </Box>
                        ) : (
                            <ImageGallery
                                images={images}
                                readonly={true}
                            />
                        )}
                    </TabPanel>

                    {/* Map tab */}
                    {(trip.latitude && trip.longitude) && (
                        <TabPanel px={0}>
                            <Box height="600px" borderRadius="md" overflow="hidden">
                                <TripMap
                                    latitude={trip.latitude}
                                    longitude={trip.longitude}
                                    locationName={trip.locationName || 'Trip Location'}
                                />
                            </Box>
                        </TabPanel>
                    )}
                </TabPanels>
            </Tabs>
        </Container>
    );
};

export default SharedTripPage;

// Source: pages\trips\TripDetailPage.tsx
import React, { useEffect, useState } from 'react';
import { useParams, useNavigate } from 'react-router-dom';
import {
    Box,
    Button,
    Container,
    Flex,
    Heading,
    Text,
    Tabs,
    TabList,
    TabPanels,
    Tab,
    TabPanel,
    HStack,
    Icon,
    Modal,
    ModalOverlay,
    ModalContent,
    ModalHeader,
    ModalFooter,
    ModalBody,
    ModalCloseButton,
    useDisclosure,
    Spinner,
    Divider,
    AlertDialog,
    AlertDialogBody,
    AlertDialogFooter,
    AlertDialogHeader,
    AlertDialogContent,
    AlertDialogOverlay,
    useToast,
} from '@chakra-ui/react';
import { FaEdit, FaTrash, FaShare, FaCalendarAlt, FaMapMarkerAlt, FaImages, FaPlus } from 'react-icons/fa';
import { format } from 'date-fns';
import tripService from '../../services/tripService';
import imageService from '../../services/imageService';
import { Trip, Image } from '../../types';
import ImageUploader from '../../components/trips/ImageUploader';
import ImageGallery from '../../components/trips/ImageGallery';
import TripMap from '../../components/trips/TripMap';
import ImageFilter, { ImageFilters } from '../../components/trips/ImageFilter';

const TripDetailPage: React.FC = () => {
    const { id } = useParams<{ id: string }>();
    const [trip, setTrip] = useState<Trip | null>(null);
    const [images, setImages] = useState<Image[]>([]);
    const [filteredImages, setFilteredImages] = useState<Image[]>([]);
    const [loading, setLoading] = useState(true);
    const [shareUrl, setShareUrl] = useState<string | null>(null);
    const [filters, setFilters] = useState<ImageFilters>({
        searchTerm: '',
        sortBy: 'newest',
        filterType: 'all',
    });
    
    const navigate = useNavigate();
    const toast = useToast();

    // Modal controls
    const {
        isOpen: isUploadOpen,
        onOpen: onUploadOpen,
        onClose: onUploadClose
    } = useDisclosure();

    const {
        isOpen: isShareOpen,
        onOpen: onShareOpen,
        onClose: onShareClose
    } = useDisclosure();

    // Delete confirmation dialog
    const {
        isOpen: isDeleteOpen,
        onOpen: onDeleteOpen,
        onClose: onDeleteClose
    } = useDisclosure();
    const cancelRef = React.useRef<HTMLButtonElement>(null!) as React.RefObject<HTMLButtonElement>;

    // Fetch trip details and images
    const fetchTripData = async () => {
        if (!id) return;

        setLoading(true);
        try {
            const tripData = await tripService.getTrip(id);
            setTrip(tripData);

            const imagesData = await imageService.getImages(id);
            setImages(imagesData);
            
            // Initially, filtered images are the same as all images
            setFilteredImages(imagesData);
        } catch (error) {
            console.error('Error fetching trip data:', error);
            toast({
                title: 'Error',
                description: 'Failed to load trip details. Please try again.',
                status: 'error',
                duration: 5000,
                isClosable: true,
            });
        } finally {
            setLoading(false);
        }
    };

    useEffect(() => {
        fetchTripData();
    }, [id]);

    // Filter and sort images whenever images array or filters change
    useEffect(() => {
        let result = [...images];
        
        // Apply search filter
        if (filters.searchTerm) {
            const term = filters.searchTerm.toLowerCase();
            result = result.filter(img => 
                img.fileName.toLowerCase().includes(term)
            );
        }
        
        // Apply type filter
        if (filters.filterType === 'ai') {
            result = result.filter(img => img.isAiGenerated);
        } else if (filters.filterType === 'regular') {
            result = result.filter(img => !img.isAiGenerated);
        }
        
        // Apply sorting
        result = result.sort((a, b) => {
            switch (filters.sortBy) {
                case 'newest':
                    return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
                case 'oldest':
                    return new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime();
                case 'name':
                    return a.fileName.localeCompare(b.fileName);
                case 'size':
                    return b.fileSize - a.fileSize;
                default:
                    return 0;
            }
        });
        
        setFilteredImages(result);
    }, [images, filters]);

    // Update filter state
    const handleFilterChange = (newFilters: ImageFilters) => {
        setFilters(newFilters);
    };

    // Share trip
    const handleShare = async () => {
        if (!trip) return;

        try {
            const response = await tripService.generateShareLink(trip.id);
            const shareId = response.shareId;

            // Construct the shareable URL
            const baseUrl = window.location.origin;
            const shareableUrl = `${baseUrl}/trips/shared/${shareId}`;

            setShareUrl(shareableUrl);
            onShareOpen();
        } catch (error) {
            console.error('Error generating share link:', error);
            toast({
                title: 'Error',
                description: 'Failed to generate share link. Please try again.',
                status: 'error',
                duration: 5000,
                isClosable: true,
            });
        }
    };

    // Copy share URL to clipboard
    const copyShareUrl = () => {
        if (!shareUrl) return;

        navigator.clipboard.writeText(shareUrl)
            .then(() => {
                toast({
                    title: 'Copied!',
                    description: 'Share link copied to clipboard.',
                    status: 'success',
                    duration: 3000,
                    isClosable: true,
                });
            })
            .catch(err => {
                console.error('Failed to copy:', err);
                toast({
                    title: 'Error',
                    description: 'Failed to copy link. Please try again.',
                    status: 'error',
                    duration: 3000,
                    isClosable: true,
                });
            });
    };

    // Delete trip
    const handleDelete = async () => {
        if (!trip) return;

        try {
            await tripService.deleteTrip(trip.id);
            toast({
                title: 'Trip deleted',
                description: `"${trip.name}" has been deleted successfully.`,
                status: 'success',
                duration: 5000,
                isClosable: true,
            });
            navigate('/trips');
        } catch (error) {
            console.error('Error deleting trip:', error);
            toast({
                title: 'Error',
                description: 'Failed to delete trip. Please try again.',
                status: 'error',
                duration: 5000,
                isClosable: true,
            });
        } finally {
            onDeleteClose();
        }
    };

    // Check if there are any AI-generated images
    const hasAiImages = images.some(img => img.isAiGenerated);

    if (loading) {
        return (
            <Flex justify="center" align="center" minH="50vh">
                <Spinner size="xl" color="brand.500" />
            </Flex>
        );
    }

    if (!trip) {
        return (
            <Container maxW="container.xl" py={8}>
                <Heading as="h1" size="xl" mb={4}>Trip Not Found</Heading>
                <Text>The trip you're looking for doesn't exist or you don't have permission to view it.</Text>
                <Button mt={4} onClick={() => navigate('/trips')}>Back to Trips</Button>
            </Container>
        );
    }

    return (
        <Container maxW="container.xl" py={8}>
            {/* Trip header */}
            <Flex
                direction={{ base: 'column', md: 'row' }}
                justify="space-between"
                align={{ base: 'start', md: 'center' }}
                mb={6}
            >
                <Box>
                    <Heading as="h1" size="xl">{trip.name}</Heading>
                    <HStack mt={2} spacing={4}>
                        <HStack>
                            <Icon as={FaCalendarAlt} color="gray.500" />
                            <Text color="gray.600">
                                {format(new Date(trip.startDate), 'MMM d, yyyy')} - {format(new Date(trip.endDate), 'MMM d, yyyy')}
                            </Text>
                        </HStack>
                        {trip.locationName && (
                            <HStack>
                                <Icon as={FaMapMarkerAlt} color="gray.500" />
                                <Text color="gray.600">{trip.locationName}</Text>
                            </HStack>
                        )}
                    </HStack>
                </Box>

                <HStack mt={{ base: 4, md: 0 }} spacing={3}>
                    <Button
                        leftIcon={<FaShare />}
                        variant="outline"
                        onClick={handleShare}
                        size={{ base: 'sm', md: 'md' }}
                    >
                        Share
                    </Button>
                    <Button
                        leftIcon={<FaEdit />}
                        variant="outline"
                        onClick={() => navigate(`/trips/${trip.id}/edit`)}
                        size={{ base: 'sm', md: 'md' }}
                    >
                        Edit
                    </Button>
                    <Button
                        leftIcon={<FaTrash />}
                        colorScheme="red"
                        variant="outline"
                        onClick={onDeleteOpen}
                        size={{ base: 'sm', md: 'md' }}
                    >
                        Delete
                    </Button>
                </HStack>
            </Flex>

            {/* Trip description */}
            {trip.description && (
                <Box mb={6}>
                    <Text>{trip.description}</Text>
                </Box>
            )}

            <Divider mb={6} />

            {/* Tabs for different trip content */}
            <Tabs colorScheme="brand" isLazy>
                <TabList>
                    <Tab><HStack><Icon as={FaImages} /><Text>Photos</Text></HStack></Tab>
                    {(trip.latitude && trip.longitude) && (
                        <Tab><HStack><Icon as={FaMapMarkerAlt} /><Text>Map</Text></HStack></Tab>
                    )}
                </TabList>

                <TabPanels>
                    {/* Photos tab */}
                    <TabPanel px={0}>
                        <Flex justify="space-between" align="center" mb={4}>
                            <Heading as="h2" size="lg">Photos</Heading>
                            <Button
                                leftIcon={<FaPlus />}
                                colorScheme="brand"
                                onClick={onUploadOpen}
                            >
                                Add Photos
                            </Button>
                        </Flex>

                        {images.length === 0 ? (
                            <Box
                                borderWidth={2}
                                borderRadius="md"
                                borderColor="gray.200"
                                borderStyle="dashed"
                                p={12}
                                textAlign="center"
                            >
                                <Icon as={FaImages} boxSize={12} color="gray.300" mb={4} />
                                <Heading as="h3" size="md" mb={2}>No Photos Yet</Heading>
                                <Text mb={4}>Start by adding photos to your trip</Text>
                                <Button
                                    leftIcon={<FaPlus />}
                                    colorScheme="brand"
                                    onClick={onUploadOpen}
                                >
                                    Add Photos
                                </Button>
                            </Box>
                        ) : (
                            <>
                                {/* Add ImageFilter component */}
                                <ImageFilter 
                                    onFilterChange={handleFilterChange} 
                                    hasAiImages={hasAiImages} 
                                />
                                
                                {/* Display count of filtered images */}
                                <Text fontSize="sm" color="gray.500" mb={4}>
                                    Showing {filteredImages.length} of {images.length} images
                                </Text>
                                
                                <ImageGallery
                                    images={filteredImages}
                                    onDelete={(imageId) => {
                                        // Update the state to remove the deleted image
                                        setImages(current => current.filter(img => img.id !== imageId));
                                    }}
                                />
                            </>
                        )}
                    </TabPanel>

                    {/* Map tab */}
                    {(trip.latitude && trip.longitude) && (
                        <TabPanel px={0}>
                            <Box height="600px" borderRadius="md" overflow="hidden">
                                <TripMap
                                    latitude={trip.latitude}
                                    longitude={trip.longitude}
                                    locationName={trip.locationName || 'Trip Location'}
                                />
                            </Box>
                        </TabPanel>
                    )}
                </TabPanels>
            </Tabs>

            {/* Upload images modal */}
            <Modal isOpen={isUploadOpen} onClose={onUploadClose} size="xl">
                <ModalOverlay />
                <ModalContent>
                    <ModalHeader>Upload Photos</ModalHeader>
                    <ModalCloseButton />
                    <ModalBody>
                        <ImageUploader
                            tripId={trip.id}
                            onUploadComplete={() => {
                                fetchTripData(); // Refresh images after upload
                                onUploadClose();
                            }}
                        />
                    </ModalBody>
                </ModalContent>
            </Modal>

            {/* Share trip modal */}
            <Modal isOpen={isShareOpen} onClose={onShareClose}>
                <ModalOverlay />
                <ModalContent>
                    <ModalHeader>Share Your Trip</ModalHeader>
                    <ModalCloseButton />
                    <ModalBody>
                        <Text mb={4}>
                            Share this link with friends and family to let them view your trip:
                        </Text>
                        <Box
                            p={3}
                            borderWidth={1}
                            borderRadius="md"
                            fontFamily="mono"
                            fontSize="sm"
                            bg="gray.50"
                            wordBreak="break-all"
                        >
                            {shareUrl}
                        </Box>
                    </ModalBody>
                    <ModalFooter>
                        <Button colorScheme="brand" mr={3} onClick={copyShareUrl}>
                            Copy Link
                        </Button>
                        <Button variant="ghost" onClick={onShareClose}>
                            Close
                        </Button>
                    </ModalFooter>
                </ModalContent>
            </Modal>

            {/* Delete confirmation dialog */}
            <AlertDialog
                isOpen={isDeleteOpen}
                leastDestructiveRef={cancelRef}
                onClose={onDeleteClose}
            >
                <AlertDialogOverlay>
                    <AlertDialogContent>
                        <AlertDialogHeader fontSize="lg" fontWeight="bold">
                            Delete Trip
                        </AlertDialogHeader>
                        <AlertDialogBody>
                            Are you sure you want to delete "{trip.name}"? This action cannot be undone.
                            All photos associated with this trip will also be deleted.
                        </AlertDialogBody>
                        <AlertDialogFooter>
                            <Button ref={cancelRef} onClick={onDeleteClose}>
                                Cancel
                            </Button>
                            <Button colorScheme="red" onClick={handleDelete} ml={3}>
                                Delete
                            </Button>
                        </AlertDialogFooter>
                    </AlertDialogContent>
                </AlertDialogOverlay>
            </AlertDialog>
        </Container>
    );
};

export default TripDetailPage;

// Source: pages\trips\TripFormPage.tsx
import React, { useEffect, useState } from 'react';
import { useParams } from 'react-router-dom';
import { Container, Spinner, Flex } from '@chakra-ui/react';
import TripForm from '../../components/trips/TripForm';
import tripService from '../../services/tripService';
import { Trip } from '../../types';

interface TripFormPageProps {
    isEditing?: boolean;
}

const TripFormPage: React.FC<TripFormPageProps> = ({ isEditing = false }) => {
    const { id } = useParams<{ id: string }>();
    const [trip, setTrip] = useState<Trip | null>(null);
    const [loading, setLoading] = useState(isEditing);

    useEffect(() => {
        const fetchTrip = async () => {
            if (isEditing && id) {
                setLoading(true);
                try {
                    const tripData = await tripService.getTrip(id);
                    setTrip(tripData);
                } catch (error) {
                    console.error('Error fetching trip:', error);
                } finally {
                    setLoading(false);
                }
            }
        };

        fetchTrip();
    }, [id, isEditing]);

    if (loading) {
        return (
            <Flex justify="center" align="center" minH="50vh">
                <Spinner size="xl" color="brand.500" />
            </Flex>
        );
    }

    return (
        <Container maxW="container.xl" py={8}>
            <TripForm initialData={trip || undefined} isEditing={isEditing} />
        </Container>
    );
};

export default TripFormPage;

// Source: pages\trips\TripMap.tsx
import React, { useEffect, useRef } from 'react';
import { Box } from '@chakra-ui/react';

interface TripMapProps {
    latitude: number;
    longitude: number;
    locationName?: string;
}

const TripMap: React.FC<TripMapProps> = ({ latitude, longitude, locationName }) => {
    const mapRef = useRef<HTMLDivElement>(null);
    const mapInstanceRef = useRef<any>(null);
    const markerRef = useRef<any>(null);

    useEffect(() => {
        if (!mapRef.current) return;

        const initMap = async () => {
            try {
                // Dynamically import leaflet to avoid SSR issues
                const L = (await import('leaflet')).default;

                // Fix leaflet's icon paths
                delete (L.Icon.Default.prototype as any)._getIconUrl;
                L.Icon.Default.mergeOptions({
                    iconRetinaUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon-2x.png',
                    iconUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-icon.png',
                    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.7.1/images/marker-shadow.png',
                });

                // Create map if it doesn't exist
                if (!mapInstanceRef.current) {
                    // Initialize the map
                    const map = L.map(mapRef.current!).setView([latitude, longitude], 13);

                    // Add OpenStreetMap tiles
                    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
                    }).addTo(map);

                    // Add marker
                    markerRef.current = L.marker([latitude, longitude]).addTo(map);

                    // Add popup with location name if provided
                    if (locationName) {
                        markerRef.current.bindPopup(locationName).openPopup();
                    }

                    // Store map instance
                    mapInstanceRef.current = map;
                } else {
                    // If map exists, update the view and marker position
                    mapInstanceRef.current.setView([latitude, longitude], 13);

                    if (markerRef.current) {
                        markerRef.current.setLatLng([latitude, longitude]);

                        if (locationName) {
                            markerRef.current.bindPopup(locationName).openPopup();
                        }
                    }
                }
            } catch (error) {
                console.error('Error initializing map:', error);
            }
        };

        initMap();

        // Cleanup function
        return () => {
            if (mapInstanceRef.current) {
                mapInstanceRef.current.remove();
                mapInstanceRef.current = null;
                markerRef.current = null;
            }
        };
    }, [latitude, longitude, locationName]);

    // Handle window resize to update map size
    useEffect(() => {
        const handleResize = () => {
            if (mapInstanceRef.current) {
                mapInstanceRef.current.invalidateSize();
            }
        };

        window.addEventListener('resize', handleResize);

        return () => {
            window.removeEventListener('resize', handleResize);
        };
    }, []);

    return (
        <Box
            ref={mapRef}
            height="100%"
            width="100%"
            borderRadius="md"
            // Add required CSS for Leaflet
            className="leaflet-container"
            sx={{
                '.leaflet-container': {
                    height: '100%',
                    width: '100%',
                }
            }}
        />
    );
};

export default TripMap;

// Source: pages\trips\TripsPage.tsx
import React, { useEffect, useState } from 'react';
import { Link as RouterLink, useNavigate } from 'react-router-dom';
import {
    Box,
    Button,
    Container,
    Flex,
    Heading,
    Text,
    SimpleGrid,
    Card,
    CardBody,
    CardFooter,
    Image,
    Stack,
    HStack,
    Icon,
    Spinner,
    useColorModeValue,
} from '@chakra-ui/react';
import { FaMapMarkerAlt, FaCalendarAlt, FaPlus, FaImages } from 'react-icons/fa';
import tripService from '../../services/tripService';
import imageService from '../../services/imageService';
import { Trip, Image as ImageType } from '../../types';
import { format } from 'date-fns';

interface TripWithCoverImage extends Trip {
    coverImage?: ImageType;
}

const TripsPage: React.FC = () => {
    const [trips, setTrips] = useState<TripWithCoverImage[]>([]);
    const [loading, setLoading] = useState(true);
    const navigate = useNavigate();

    const borderColor = useColorModeValue('gray.200', 'gray.700');

    useEffect(() => {
        const fetchTrips = async () => {
            setLoading(true);
            try {
                const tripsData = await tripService.getTrips();

                // For each trip, try to get a cover image
                const tripsWithCoverImages = await Promise.all(
                    tripsData.map(async (trip) => {
                        try {
                            const images = await imageService.getImages(trip.id);
                            return {
                                ...trip,
                                coverImage: images.length > 0 ? images[0] : undefined,
                            };
                        } catch (error) {
                            console.error(`Error fetching images for trip ${trip.id}:`, error);
                            return trip;
                        }
                    })
                );

                setTrips(tripsWithCoverImages);
            } catch (error) {
                console.error('Error fetching trips:', error);
            } finally {
                setLoading(false);
            }
        };

        fetchTrips();
    }, []);

    const handleCreateTrip = () => {
        navigate('/trips/new');
    };

    if (loading) {
        return (
            <Flex justify="center" align="center" minH="50vh">
                <Spinner size="xl" color="brand.500" />
            </Flex>
        );
    }

    return (
        <Container maxW="container.xl" py={8}>
            <Flex
                direction={{ base: 'column', md: 'row' }}
                justify="space-between"
                align={{ base: 'start', md: 'center' }}
                mb={8}
            >
                <Heading as="h1" size="xl" mb={{ base: 4, md: 0 }}>
                    My Trips
                </Heading>
                <Button
                    leftIcon={<FaPlus />}
                    colorScheme="brand"
                    onClick={handleCreateTrip}
                    size={{ base: 'md', md: 'lg' }}
                >
                    Create New Trip
                </Button>
            </Flex>

            {trips.length === 0 ? (
                <Box
                    borderWidth={2}
                    borderRadius="lg"
                    borderColor="gray.200"
                    borderStyle="dashed"
                    p={12}
                    textAlign="center"
                >
                    <Icon as={FaMapMarkerAlt} boxSize={12} color="gray.300" mb={4} />
                    <Heading as="h3" size="md" mb={2}>No Trips Yet</Heading>
                    <Text mb={4}>Start by creating your first trip</Text>
                    <Button
                        leftIcon={<FaPlus />}
                        colorScheme="brand"
                        onClick={handleCreateTrip}
                    >
                        Create New Trip
                    </Button>
                </Box>
            ) : (
                <SimpleGrid columns={{ base: 1, sm: 2, md: 3, lg: 4 }} spacing={6}>
                    {trips.map((trip) => (
                        <Card
                            key={trip.id}
                            overflow="hidden"
                            variant="outline"
                            borderColor={borderColor}
                            borderRadius="lg"
                            _hover={{
                                transform: 'translateY(-5px)',
                                boxShadow: 'lg',
                                borderColor: 'brand.300',
                            }}
                            transition="all 0.3s ease"
                            height="100%"
                        >
                            <Box height="200px" bg="gray.100" position="relative">
                                {trip.coverImage ? (
                                    <Image
                                        src={trip.coverImage.filePath}
                                        alt={trip.name}
                                        objectFit="cover"
                                        height="100%"
                                        width="100%"
                                    />
                                ) : (
                                    <Flex
                                        height="100%"
                                        align="center"
                                        justify="center"
                                        direction="column"
                                        p={4}
                                        color="gray.400"
                                    >
                                        <Icon as={FaImages} boxSize={10} mb={2} />
                                        <Text>No photos yet</Text>
                                    </Flex>
                                )}

                                {trip.locationName && (
                                    <HStack
                                        position="absolute"
                                        bottom={0}
                                        left={0}
                                        right={0}
                                        p={2}
                                        bg="blackAlpha.600"
                                        color="white"
                                        spacing={2}
                                    >
                                        <Icon as={FaMapMarkerAlt} />
                                        <Text fontSize="sm" noOfLines={1}>
                                            {trip.locationName}
                                        </Text>
                                    </HStack>
                                )}
                            </Box>

                            <CardBody>
                                <Stack spacing={2}>
                                    <Heading as="h3" size="md" noOfLines={1}>
                                        {trip.name}
                                    </Heading>

                                    <HStack>
                                        <Icon as={FaCalendarAlt} color="gray.500" />
                                        <Text fontSize="sm" color="gray.600">
                                            {format(new Date(trip.startDate), 'MMM d')} - {format(new Date(trip.endDate), 'MMM d, yyyy')}
                                        </Text>
                                    </HStack>

                                    {trip.description && (
                                        <Text fontSize="sm" noOfLines={2} color="gray.600">
                                            {trip.description}
                                        </Text>
                                    )}
                                </Stack>
                            </CardBody>

                            <CardFooter pt={0}>
                                <Button
                                    as={RouterLink}
                                    to={`/trips/${trip.id}`}
                                    variant="solid"
                                    colorScheme="brand"
                                    width="100%"
                                >
                                    View Trip
                                </Button>
                            </CardFooter>
                        </Card>
                    ))}
                </SimpleGrid>
            )}
        </Container>
    );
};

export default TripsPage;

